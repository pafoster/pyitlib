<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>discrete_random_variable &#8212; pyitlib 0.3.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=2bf1fcf8" />
    
    <script src="../_static/documentation_options.js?v=4621528c"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pyitlib 0.3.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">discrete_random_variable</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for discrete_random_variable</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># The MIT License (MIT)</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2016 Peter Foster &lt;pyitlib@gmx.us&gt;</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1"># in the Software without restriction, including without limitation the rights</span>
<span class="c1"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1"># furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in</span>
<span class="c1"># all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="c1"># SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module implements various information-theoretic quantities for discrete</span>
<span class="sd">random variables.</span>

<span class="sd">For ease of reference, function names follow the following convention:</span>

<span class="sd">Function names beginning with &quot;entropy&quot; : Entropy measures</span>

<span class="sd">Function names beginning with &quot;information&quot; : Mutual information measures</span>

<span class="sd">Function names beginning with &quot;divergence&quot; : Divergence measures</span>

<span class="sd">Function names ending with &quot;pmf&quot; : Functions operating on arrays of probability</span>
<span class="sd">mass assignments (as opposed realisations of random variables)</span>

<span class="sd">================================================== ===================== ============== ======== ======== =======================</span>
<span class="sd">Function                                           Generalises           Non-negativity Symmetry Identity Metric properties</span>
<span class="sd">================================================== ===================== ============== ======== ======== =======================</span>
<span class="sd">:meth:`divergence_jensenshannon`                                         Yes            Yes      Yes      Square root is a metric</span>
<span class="sd">:meth:`divergence_jensenshannon_pmf`                                     Yes            Yes      Yes      Square root is a metric</span>
<span class="sd">:meth:`divergence_kullbackleibler`                                       Yes            No       Yes</span>
<span class="sd">:meth:`divergence_kullbackleibler_pmf`                                   Yes            No       Yes</span>
<span class="sd">:meth:`divergence_kullbackleibler_symmetrised`                           Yes            Yes      Yes</span>
<span class="sd">:meth:`divergence_kullbackleibler_symmetrised_pmf`                       Yes            Yes      Yes</span>
<span class="sd">:meth:`entropy`                                                          Yes</span>
<span class="sd">:meth:`entropy_conditional`                                              Yes            No       No</span>
<span class="sd">:meth:`entropy_cross`                                                    Yes            No       No</span>
<span class="sd">:meth:`entropy_cross_pmf`                                                Yes            No       No</span>
<span class="sd">:meth:`entropy_joint`                                                    Yes            Yes      No</span>
<span class="sd">:meth:`entropy_pmf`                                                      Yes</span>
<span class="sd">:meth:`entropy_residual`                           information_variation Yes            Yes      No</span>
<span class="sd">:meth:`information_binding`                        information_mutual    Yes            Yes      No</span>
<span class="sd">:meth:`information_co`                             information_mutual    No             No       No</span>
<span class="sd">:meth:`information_enigmatic`                                            No             Yes      No</span>
<span class="sd">:meth:`information_exogenous_local`                                      Yes            Yes      No</span>
<span class="sd">:meth:`information_interaction`                    information_mutual    No             No       No</span>
<span class="sd">:meth:`information_lautum`                                               Yes            No       No</span>
<span class="sd">:meth:`information_multi`                          information_mutual    Yes            Yes      No</span>
<span class="sd">:meth:`information_mutual`                                               Yes            Yes      No</span>
<span class="sd">:meth:`information_mutual_conditional`                                   Yes            No       No</span>
<span class="sd">:meth:`information_mutual_normalised`                                    Yes            See docs No       See docs</span>
<span class="sd">:meth:`information_variation`                                            Yes            Yes      No       Is a metric</span>
<span class="sd">================================================== ===================== ============== ======== ======== =======================</span>

<span class="sd">.. rubric:: References</span>
<span class="sd">.. [AbPl12] Abdallah, S.A.; Plumbley, M.D.: A measure of statistical \</span>
<span class="sd">complexity based on predictive information with application to finite spin \</span>
<span class="sd">systems. In: Physics Letters A, Vol. 376, No. 4, 2012, P. 275-281.</span>
<span class="sd">.. [Bell03] Bell, A.J.: The co-information lattice. In: Proceedings of the \</span>
<span class="sd">International Workshop on Independent Component Analysis and Blind Signal \</span>
<span class="sd">Separation. 2003.</span>
<span class="sd">.. [CoTh06] Cover, T.M.; Thomas, J.A.: Elements of information theory \</span>
<span class="sd">(2nd ed.). John Wiley &amp; Sons, 2006.</span>
<span class="sd">.. [Croo15] Crooks, G.E.: On measures of entropy and information. \</span>
<span class="sd">http://threeplusone.com/info, retrieved 2017-03-16.</span>
<span class="sd">.. [GaSa95] Gale, W.A.; Sampson, G.: Good‐Turing frequency estimation \</span>
<span class="sd">without tears. In: Journal of Quantitative Linguistics, \</span>
<span class="sd">Vol. 2, No. 3, 1995, P. 217-237.</span>
<span class="sd">.. [Han78] Han, T.S.: Nonnegative entropy measures of multivariate symmetric \</span>
<span class="sd">correlations. In: Information and Control, Vol. 36, 1978, P. 133-156.</span>
<span class="sd">.. [HaSt09] Hausser, J.; Strimmer, K.: Entropy inference and the James-Stein \</span>
<span class="sd">estimator, with application to nonlinear gene association networks. \</span>
<span class="sd">In: Journal of Machine Learning Research, Vol. 10, 2009, P. 1469-1484.</span>
<span class="sd">.. [JaBr03] Jakulin, A.; Bratko, I.: Quantifying and visualizing attribute \</span>
<span class="sd">interactions. arXiv preprint cs/0308002, 2003.</span>
<span class="sd">.. [JaEC11] James, R.G.; Ellison, C.J.; Crutchfield, J.P.: Anatomy of a bit: \</span>
<span class="sd">Information in a time series observation. In: Chaos: An Interdisciplinary \</span>
<span class="sd">Journal of Nonlinear Science, Vol. 21, No. 3, 2011.</span>
<span class="sd">.. [Lin91] Lin, J.: Divergence measures based on the Shannon entropy. \</span>
<span class="sd">In: IEEE Transactions on Information theory, Vol. 37, No. 1, 1991, P. 145-151.</span>
<span class="sd">.. [Meil03] Meilă, M.: Comparing clusterings by the variation of \</span>
<span class="sd">information. In: Learning theory and kernel machines. \</span>
<span class="sd">Springer, 2003, P. 173-187.</span>
<span class="sd">.. [Murp12] Murphy, K. P.: Machine learning: a probabilistic perspective. \</span>
<span class="sd">MIT press, 2012.</span>
<span class="sd">.. [PaVe08] Palomar, D. P.; Verdú, S.: Lautum information. In: IEEE \</span>
<span class="sd">transactions on information theory, Vol. 54, No. 3, 2008, P. 964-975.</span>
<span class="sd">.. [StVe98] Studený, M.; Vejnarová, J.: The multiinformation function \</span>
<span class="sd">as a tool for measuring stochastic dependence. In: Learning in graphical \</span>
<span class="sd">models. Springer Netherlands, 1998, P. 261-297.</span>
<span class="sd">.. [VeWe06] Verdú, S.; Weissman, T.: Erasure entropy. In: Proc. IEEE \</span>
<span class="sd">International Symposium on Information Theory, 2006, P. 98-102.</span>
<span class="sd">.. [Wata60] Watanabe, S.: Information theoretical analysis of multivariate \</span>
<span class="sd">correlation. In: IBM Journal of research and development, \</span>
<span class="sd">Vol. 4, No. 1, 1960, P. 66-82.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="n">NONE_REPLACEMENT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">32768</span>

<span class="c1"># Aims of project: Comprehensive, Simple-to-use (avoid lots of function calls,</span>
<span class="c1"># prefer flags, convenient defaults for possible interactive use). Focus on</span>
<span class="c1"># data analysis. Documentation.</span>
<span class="c1"># TODO Add guidance on which estimator to use (within module doc)</span>
<span class="c1"># TODO Add notes on interpretation of each measure (within each function doc)</span>
<span class="c1"># TODO Add basic equalities and properties, followed by interpretation (within</span>
<span class="c1"># each function doc)</span>
<span class="c1"># TODO Note about which measures are metrics (within each function doc).</span>
<span class="c1"># TODO Add information diagrams (within each function doc).</span>
<span class="c1"># TODO Implement joint observation mapping function</span>
<span class="c1"># encode/map_joint_observations. This works by sorting and returning unique</span>
<span class="c1"># observations, similar to entropy_joint()</span>
<span class="c1"># TODO Implement generalised Jensen-Shannon divergence</span>
<span class="c1"># TODO Information bottleneck and deterministic information bottleneck (See</span>
<span class="c1"># Strose and Schwab 2016). NB Can be used in either supervised or unsupervised</span>
<span class="c1"># manner. Implement in separate module. Implement the earlier hierarchical</span>
<span class="c1"># aggolerative clustering approach as well?. The approaches should also</span>
<span class="c1"># incorporate `de-noising&#39; capability: With probability p, corrupt observations</span>
<span class="c1"># with a random symbol. The learnt model should also have a way of discarding</span>
<span class="c1"># un-used input features (feature selection).</span>
<span class="c1"># TODO Re-arrange functions based on dependencies</span>
<span class="c1"># TODO Add information in documentation on when quantities are maximised or</span>
<span class="c1"># minimised</span>


<div class="viewcode-block" id="entropy_residual">
<a class="viewcode-back" href="../index.html#discrete_random_variable.entropy_residual">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">entropy_residual</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the estimated residual entropy [JaEC11] (also known as erasure</span>
<span class="sd">    entropy [VeWe06]) for an array X containing realisations of discrete random</span>
<span class="sd">    variables.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X_1, \ldots, X_n`, the residual</span>
<span class="sd">    entropy :math:`R(X_1, \\ldots, X_n)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        R(X_1, \\ldots, X_n) = H(X_1, \\ldots, X_n) - B(X_1, \\ldots, X_n)</span>

<span class="sd">    where :math:`H(\\cdot, \\ldots, \\cdot)` denotes the joint entropy and</span>
<span class="sd">    where :math:`B(\\cdot, \\ldots, \\cdot)` denotes the binding information.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Residual information is estimated based on frequency tables, using the</span>
<span class="sd">    following functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although residual</span>
<span class="sd">    information is a non-negative quantity, depending on the chosen estimator</span>
<span class="sd">    the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        An array containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        array; multiple random variables may be specified using preceding axes.</span>
<span class="sd">        When X.ndim==1, returns a scalar and is equivalent to entropy(). When</span>
<span class="sd">        X.ndim&gt;1, returns a scalar based on jointly considering all random</span>
<span class="sd">        variables indexed in the array. X may not contain (floating point) NaN</span>
<span class="sd">        values. Missing data may be specified using numpy masked arrays, as</span>
<span class="sd">        well as using standard numpy array/array-like objects; see below</span>
<span class="sd">        for details.</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X : numpy array (or array-like object such as a list of \</span>
<span class="sd">    immutables, as accepted by np.array())</span>
<span class="sd">        An array specifying the alphabet/alphabets of possible outcomes that</span>
<span class="sd">        random variable realisations in array X may assume. Defaults to None,</span>
<span class="sd">        in which case the alphabet/alphabets of possible outcomes is/are</span>
<span class="sd">        implicitly based the observed outcomes in array X, with no additional,</span>
<span class="sd">        unobserved outcomes. In combination with any estimator other than</span>
<span class="sd">        maximum likelihood, it may be useful to specify alphabets including</span>
<span class="sd">        unobserved outcomes. For such cases, successive possible outcomes of a</span>
<span class="sd">        random variable are indexed by the last axis in Alphabet_X; multiple</span>
<span class="sd">        alphabets may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1]. Alphabets of different sizes may</span>
<span class="sd">        be specified either using numpy masked arrays, or by padding with the</span>
<span class="sd">        chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying multiple alphabets, an alphabet of possible joint</span>
<span class="sd">        outcomes is always implicit from the alphabets of possible (marginal)</span>
<span class="sd">        outcomes in Alphabet_X. For example, specifying</span>
<span class="sd">        Alphabet_X=np.array(((1,2),(1,2))) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True, an additional dimension of length one is appended to</span>
<span class="sd">        the returned array, facilitating any broadcast operations required by</span>
<span class="sd">        the user (defaults to False).</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H_joint</span> <span class="o">=</span> <span class="n">entropy_joint</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">)</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">H_joint</span> <span class="o">-</span> <span class="n">information_binding</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">R</span></div>



<div class="viewcode-block" id="information_exogenous_local">
<a class="viewcode-back" href="../index.html#discrete_random_variable.information_exogenous_local">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">information_exogenous_local</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the estimated exogenous local information [JaEC11] for an array X</span>
<span class="sd">    containing realisations of discrete random variables.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X_1, \ldots, X_n`, the exogenous</span>
<span class="sd">    local information :math:`W(X_1, \\ldots, X_n)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        W(X_1, \\ldots, X_n) = T(X_1, \\ldots, X_n) + B(X_1, \\ldots, X_n)</span>

<span class="sd">    where :math:`T(\\cdot, \\ldots, \\cdot)` denotes the multi-information and</span>
<span class="sd">    where :math:`B(\\cdot, \\ldots, \\cdot)` denotes the binding information.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Exogenous local information is estimated based on frequency tables, using</span>
<span class="sd">    the following functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although exogenous</span>
<span class="sd">    local information is a non-negative quantity, depending on the chosen</span>
<span class="sd">    estimator the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        An array containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        array; multiple random variables may be specified using preceding axes.</span>
<span class="sd">        When X.ndim==1, returns the scalar 0. When X.ndim&gt;1, returns a scalar</span>
<span class="sd">        based on jointly considering all random variables indexed in the array.</span>
<span class="sd">        X may not contain (floating point) NaN values. Missing data may be</span>
<span class="sd">        specified using numpy masked arrays, as well as using standard</span>
<span class="sd">        numpy array/array-like objects; see below for details.</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X : numpy array (or array-like object such as a list of \</span>
<span class="sd">    immutables, as accepted by np.array())</span>
<span class="sd">        An array specifying the alphabet/alphabets of possible outcomes that</span>
<span class="sd">        random variable realisations in array X may assume. Defaults to None,</span>
<span class="sd">        in which case the alphabet/alphabets of possible outcomes is/are</span>
<span class="sd">        implicitly based the observed outcomes in array X, with no additional,</span>
<span class="sd">        unobserved outcomes. In combination with any estimator other than</span>
<span class="sd">        maximum likelihood, it may be useful to specify alphabets including</span>
<span class="sd">        unobserved outcomes. For such cases, successive possible outcomes of a</span>
<span class="sd">        random variable are indexed by the last axis in Alphabet_X; multiple</span>
<span class="sd">        alphabets may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1]. Alphabets of different sizes may</span>
<span class="sd">        be specified either using numpy masked arrays, or by padding with the</span>
<span class="sd">        chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying multiple alphabets, an alphabet of possible joint</span>
<span class="sd">        outcomes is always implicit from the alphabets of possible (marginal)</span>
<span class="sd">        outcomes in Alphabet_X. For example, specifying</span>
<span class="sd">        Alphabet_X=np.array(((1,2),(1,2))) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True, an additional dimension of length one is appended to</span>
<span class="sd">        the returned array, facilitating any broadcast operations required by</span>
<span class="sd">        the user (defaults to False).</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">information_binding</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span>
    <span class="p">)</span> <span class="o">+</span> <span class="n">information_multi</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">W</span></div>



<div class="viewcode-block" id="information_enigmatic">
<a class="viewcode-back" href="../index.html#discrete_random_variable.information_enigmatic">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">information_enigmatic</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="c1"># Note: can be negative</span>
    <span class="c1"># Note: equals multivariate mutual information when N=3, can test for this</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the estimated enigmatic information [JaEC11] for an array X</span>
<span class="sd">    containing realisations of discrete random variables.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X_1, \ldots, X_n`, the enigmatic</span>
<span class="sd">    information :math:`Q(X_1, \\ldots, X_n)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        Q(X_1, \\ldots, X_n) = T(X_1, \\ldots, X_n) - B(X_1, \\ldots, X_n)</span>

<span class="sd">    where :math:`T(\\cdot, \\ldots, \\cdot)` denotes the multi-information and</span>
<span class="sd">    where :math:`B(\\cdot, \\ldots, \\cdot)` denotes the binding information.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Enigmatic information is estimated based on frequency tables, using the</span>
<span class="sd">    following functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although enigmatic</span>
<span class="sd">    information is a non-negative quantity, depending on the chosen estimator</span>
<span class="sd">    the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        An array containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        array; multiple random variables may be specified using preceding axes.</span>
<span class="sd">        When X.ndim==1, returns the scalar 0. When X.ndim&gt;1, returns a scalar</span>
<span class="sd">        based on jointly considering all random variables indexed in the array.</span>
<span class="sd">        X may not contain (floating point) NaN values. Missing data may be</span>
<span class="sd">        specified using numpy masked arrays, as well as using standard</span>
<span class="sd">        numpy array/array-like objects; see below for details.</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X : numpy array (or array-like object such as a list of \</span>
<span class="sd">    immutables, as accepted by np.array())</span>
<span class="sd">        An array specifying the alphabet/alphabets of possible outcomes that</span>
<span class="sd">        random variable realisations in array X may assume. Defaults to None,</span>
<span class="sd">        in which case the alphabet/alphabets of possible outcomes is/are</span>
<span class="sd">        implicitly based the observed outcomes in array X, with no additional,</span>
<span class="sd">        unobserved outcomes. In combination with any estimator other than</span>
<span class="sd">        maximum likelihood, it may be useful to specify alphabets including</span>
<span class="sd">        unobserved outcomes. For such cases, successive possible outcomes of a</span>
<span class="sd">        random variable are indexed by the last axis in Alphabet_X; multiple</span>
<span class="sd">        alphabets may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1]. Alphabets of different sizes may</span>
<span class="sd">        be specified either using numpy masked arrays, or by padding with the</span>
<span class="sd">        chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying multiple alphabets, an alphabet of possible joint</span>
<span class="sd">        outcomes is always implicit from the alphabets of possible (marginal)</span>
<span class="sd">        outcomes in Alphabet_X. For example, specifying</span>
<span class="sd">        Alphabet_X=np.array(((1,2),(1,2))) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True, an additional dimension of length one is appended to</span>
<span class="sd">        the returned array, facilitating any broadcast operations required by</span>
<span class="sd">        the user (defaults to False).</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">information_multi</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span>
    <span class="p">)</span> <span class="o">-</span> <span class="n">information_binding</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span><span class="p">:</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">Q</span></div>



<div class="viewcode-block" id="information_interaction">
<a class="viewcode-back" href="../index.html#discrete_random_variable.information_interaction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">information_interaction</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the estimated interaction information [JaBr03] for an array X</span>
<span class="sd">    containing realisations of discrete random variables.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X_1, \ldots, X_n`, the interaction</span>
<span class="sd">    information :math:`\\mathrm{Int}(X_1, \\ldots, X_n)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \\mathrm{Int}(X_1, \\ldots, X_n) = - \\sum_{T \\subseteq</span>
<span class="sd">        \\{1,\\ldots, n\\}} (-1)^{n-|T|}  H(X_i : i \in T)</span>

<span class="sd">    where :math:`H(X_i : i \in T)` denotes the joint entropy of the subset of</span>
<span class="sd">    random variables specified by :math:`T`. Thus, interaction information is</span>
<span class="sd">    an alternating sum of joint entropies, with the sets of random variables</span>
<span class="sd">    used to compute the joint entropy in each term selected from the power set</span>
<span class="sd">    of available random variables.</span>

<span class="sd">    Note that interaction information is equal in magnitude to the</span>
<span class="sd">    co-information :math:`I(X_1, \\ldots, X_n)`, with equality for the case</span>
<span class="sd">    where :math:`n` is even,</span>

<span class="sd">    .. math::</span>
<span class="sd">        \\mathrm{Int}(X_1, \\ldots, X_n) = (-1)^n I(X_1, \\ldots, X_n).</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Interaction information is estimated based on frequency tables, using the</span>
<span class="sd">    following functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">    See below for a list of available estimators. Note that although</span>
<span class="sd">    interaction information is a non-negative quantity, depending on the chosen</span>
<span class="sd">    estimator the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        An array containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        array; multiple random variables may be specified using preceding axes.</span>
<span class="sd">        When X.ndim==1, returns a scalar and is equivalent to -1*entropy().</span>
<span class="sd">        When X.ndim&gt;1, returns a scalar based on jointly considering all random</span>
<span class="sd">        variables indexed in the array. X may not contain (floating point) NaN</span>
<span class="sd">        values. Missing data may be specified using numpy masked arrays, as</span>
<span class="sd">        well as using standard numpy array/array-like objects; see below</span>
<span class="sd">        for details.</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X : numpy array (or array-like object such as a list of \</span>
<span class="sd">    immutables, as accepted by np.array())</span>
<span class="sd">        An array specifying the alphabet/alphabets of possible outcomes that</span>
<span class="sd">        random variable realisations in array X may assume. Defaults to None,</span>
<span class="sd">        in which case the alphabet/alphabets of possible outcomes is/are</span>
<span class="sd">        implicitly based the observed outcomes in array X, with no additional,</span>
<span class="sd">        unobserved outcomes. In combination with any estimator other than</span>
<span class="sd">        maximum likelihood, it may be useful to specify alphabets including</span>
<span class="sd">        unobserved outcomes. For such cases, successive possible outcomes of a</span>
<span class="sd">        random variable are indexed by the last axis in Alphabet_X; multiple</span>
<span class="sd">        alphabets may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1]. Alphabets of different sizes may</span>
<span class="sd">        be specified either using numpy masked arrays, or by padding with the</span>
<span class="sd">        chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying multiple alphabets, an alphabet of possible joint</span>
<span class="sd">        outcomes is always implicit from the alphabets of possible (marginal)</span>
<span class="sd">        outcomes in Alphabet_X. For example, specifying</span>
<span class="sd">        Alphabet_X=np.array(((1,2),(1,2))) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True, an additional dimension of length one is appended to</span>
<span class="sd">        the returned array, facilitating any broadcast operations required by</span>
<span class="sd">        the user (defaults to False).</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_X</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg X is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args X and Alphabet_X do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_map_observations_to_integers</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">),</span> <span class="p">(</span><span class="n">fill_value_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">S</span>

    <span class="c1"># Re-shape X, so that we may handle multi-dimensional arrays equivalently</span>
    <span class="c1"># and iterate across 0th axis</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">_increment_binary_vector</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">I</span> <span class="o">-=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span><span class="p">))</span> <span class="o">*</span> <span class="n">entropy_joint</span><span class="p">(</span>
            <span class="n">X</span><span class="p">[</span><span class="n">M</span><span class="p">],</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">[</span><span class="n">M</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">_increment_binary_vector</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span><span class="p">:</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">I</span></div>



<div class="viewcode-block" id="information_co">
<a class="viewcode-back" href="../index.html#discrete_random_variable.information_co">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">information_co</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the estimated co-information [Bell03] for an array X containing</span>
<span class="sd">    realisations of discrete random variables.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X_1, \ldots, X_n`, the</span>
<span class="sd">    co-information :math:`I(X_1, \\ldots, X_n)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        I(X_1, \\ldots, X_n) = - \\sum_{T \\subseteq \\{1,\\ldots, n\\}}</span>
<span class="sd">        (-1)^{|T|}  H(X_i : i \in T)</span>

<span class="sd">    where :math:`H(X_i : i \in T)` denotes the joint entropy of the subset of</span>
<span class="sd">    random variables specified by :math:`T`. Thus, co-information is an</span>
<span class="sd">    alternating sum of joint entropies, with the sets of random variables used</span>
<span class="sd">    to compute the joint entropy in each term selected from the power set of</span>
<span class="sd">    available random variables.</span>

<span class="sd">    Note that co-information is equal in magnitude to the interaction</span>
<span class="sd">    information :math:`\\mathrm{Int}(X_1, \\ldots, X_n)`, with equality for the</span>
<span class="sd">    case where :math:`n` is even,</span>

<span class="sd">    .. math::</span>
<span class="sd">        I(X_1, \\ldots, X_n) = (-1)^n \\mathrm{Int}(X_1, \\ldots, X_n).</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Co-information is estimated based on frequency tables, using the following</span>
<span class="sd">    functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">    See below for a list of available estimators. Note that although</span>
<span class="sd">    co-information is a non-negative quantity, depending on the chosen</span>
<span class="sd">    estimator the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        An array containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        array; multiple random variables may be specified using preceding axes.</span>
<span class="sd">        When X.ndim==1, returns a scalar and is equivalent to entropy(). When</span>
<span class="sd">        X.ndim&gt;1, returns a scalar based on jointly considering all random</span>
<span class="sd">        variables indexed in the array. X may not contain (floating point) NaN</span>
<span class="sd">        values. Missing data may be specified using numpy masked arrays, as</span>
<span class="sd">        well as using standard numpy array/array-like objects; see below</span>
<span class="sd">        for details.</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X : numpy array (or array-like object such as a list of \</span>
<span class="sd">    immutables, as accepted by np.array())</span>
<span class="sd">        An array specifying the alphabet/alphabets of possible outcomes that</span>
<span class="sd">        random variable realisations in array X may assume. Defaults to None,</span>
<span class="sd">        in which case the alphabet/alphabets of possible outcomes is/are</span>
<span class="sd">        implicitly based the observed outcomes in array X, with no additional,</span>
<span class="sd">        unobserved outcomes. In combination with any estimator other than</span>
<span class="sd">        maximum likelihood, it may be useful to specify alphabets including</span>
<span class="sd">        unobserved outcomes. For such cases, successive possible outcomes of a</span>
<span class="sd">        random variable are indexed by the last axis in Alphabet_X; multiple</span>
<span class="sd">        alphabets may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1]. Alphabets of different sizes may</span>
<span class="sd">        be specified either using numpy masked arrays, or by padding with the</span>
<span class="sd">        chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying multiple alphabets, an alphabet of possible joint</span>
<span class="sd">        outcomes is always implicit from the alphabets of possible (marginal)</span>
<span class="sd">        outcomes in Alphabet_X. For example, specifying</span>
<span class="sd">        Alphabet_X=np.array(((1,2),(1,2))) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True, an additional dimension of length one is appended to</span>
<span class="sd">        the returned array, facilitating any broadcast operations required by</span>
<span class="sd">        the user (defaults to False).</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_X</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg X is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args X and Alphabet_X do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_map_observations_to_integers</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">),</span> <span class="p">(</span><span class="n">fill_value_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">S</span>

    <span class="c1"># Re-shape X, so that we may handle multi-dimensional arrays equivalently</span>
    <span class="c1"># and iterate across 0th axis</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">_increment_binary_vector</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">I</span> <span class="o">-=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span><span class="p">))</span> <span class="o">*</span> <span class="n">entropy_joint</span><span class="p">(</span>
            <span class="n">X</span><span class="p">[</span><span class="n">M</span><span class="p">],</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">[</span><span class="n">M</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">_increment_binary_vector</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span><span class="p">:</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">I</span></div>



<div class="viewcode-block" id="information_binding">
<a class="viewcode-back" href="../index.html#discrete_random_variable.information_binding">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">information_binding</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the estimated binding information [AbPl12] (also known as dual</span>
<span class="sd">    total correlation [Han78]) for an array X containing realisations of</span>
<span class="sd">    discrete random variables.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X_1, \ldots, X_n`, the binding</span>
<span class="sd">    information :math:`B(X_1, \\ldots, X_n)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        B(X_1, \\ldots, X_n) = H(X_1, \\ldots, X_n) -</span>
<span class="sd">        \\sum_{i=1}^{n} H(X_i | X_1, \\ldots X_{i-1}, X_{i+1}, \\ldots, X_n)</span>

<span class="sd">    where :math:`H(\\cdot)` denotes the entropy and where</span>
<span class="sd">    :math:`H(\\cdot | \\cdot)` denotes the conditional entropy.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Binding information is estimated based on frequency tables, using the</span>
<span class="sd">    following functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although binding</span>
<span class="sd">    information is a non-negative quantity, depending on the chosen estimator</span>
<span class="sd">    the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        An array containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        array; multiple random variables may be specified using preceding axes.</span>
<span class="sd">        When X.ndim==1, returns the scalar 0. When X.ndim&gt;1, returns a scalar</span>
<span class="sd">        based on jointly considering all random variables indexed in the array.</span>
<span class="sd">        X may not contain (floating point) NaN values. Missing data may be</span>
<span class="sd">        specified using numpy masked arrays, as well as using standard</span>
<span class="sd">        numpy array/array-like objects; see below for details.</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X : numpy array (or array-like object such as a list of \</span>
<span class="sd">    immutables, as accepted by np.array())</span>
<span class="sd">        An array specifying the alphabet/alphabets of possible outcomes that</span>
<span class="sd">        random variable realisations in array X may assume. Defaults to None,</span>
<span class="sd">        in which case the alphabet/alphabets of possible outcomes is/are</span>
<span class="sd">        implicitly based the observed outcomes in array X, with no additional,</span>
<span class="sd">        unobserved outcomes. In combination with any estimator other than</span>
<span class="sd">        maximum likelihood, it may be useful to specify alphabets including</span>
<span class="sd">        unobserved outcomes. For such cases, successive possible outcomes of a</span>
<span class="sd">        random variable are indexed by the last axis in Alphabet_X; multiple</span>
<span class="sd">        alphabets may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1]. Alphabets of different sizes may</span>
<span class="sd">        be specified either using numpy masked arrays, or by padding with the</span>
<span class="sd">        chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying multiple alphabets, an alphabet of possible joint</span>
<span class="sd">        outcomes is always implicit from the alphabets of possible (marginal)</span>
<span class="sd">        outcomes in Alphabet_X. For example, specifying</span>
<span class="sd">        Alphabet_X=np.array(((1,2),(1,2))) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True, an additional dimension of length one is appended to</span>
<span class="sd">        the returned array, facilitating any broadcast operations required by</span>
<span class="sd">        the user (defaults to False).</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span><span class="p">)</span>

    <span class="c1"># Exceptions needed to create Alphabet_X correctly if None</span>
    <span class="c1"># Not all of these are needed, however we include them for consistency.</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_X</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg X is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args X and Alphabet_X do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_map_observations_to_integers</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">),</span> <span class="p">(</span><span class="n">fill_value_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">S</span>

    <span class="c1"># Exceptions thrown by entropy_joint</span>
    <span class="n">H_joint</span> <span class="o">=</span> <span class="n">entropy_joint</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">H_joint</span>
    <span class="c1"># Re-shape X, so that we may handle multi-dimensional arrays equivalently</span>
    <span class="c1"># and iterate across 0th axis</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">B</span> <span class="o">-=</span> <span class="n">H_joint</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">+=</span> <span class="n">entropy_joint</span><span class="p">(</span>
                <span class="n">X</span><span class="p">[</span><span class="n">M</span> <span class="o">!=</span> <span class="n">i</span><span class="p">],</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">[</span><span class="n">M</span> <span class="o">!=</span> <span class="n">i</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">B</span></div>



<div class="viewcode-block" id="information_multi">
<a class="viewcode-back" href="../index.html#discrete_random_variable.information_multi">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">information_multi</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the estimated multi-information [StVe98] (also known as total</span>
<span class="sd">    correlation [Wata60]) for an array X containing realisations of discrete</span>
<span class="sd">    random variables.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X_1, \ldots, X_n`, the</span>
<span class="sd">    multi-information :math:`T(X_1, \\ldots, X_n)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        T(X_1, \\ldots, X_n) = \\left( \\sum_{i=1}^{n} H(X_i) \\right) -</span>
<span class="sd">        H(X_1, \\ldots, X_n)</span>

<span class="sd">    where :math:`H(\\cdot)` denotes the entropy and where</span>
<span class="sd">    :math:`H(\\cdot, \\ldots, \\cdot)` denotes the joint entropy.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Multi-information is estimated based on frequency tables, using the</span>
<span class="sd">    following functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although</span>
<span class="sd">    multi-information is a non-negative quantity, depending on the chosen</span>
<span class="sd">    estimator the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        An array containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        array; multiple random variables may be specified using preceding axes.</span>
<span class="sd">        When X.ndim==1, returns the scalar 0. When X.ndim&gt;1, returns a scalar</span>
<span class="sd">        based on jointly considering all random variables indexed in the array.</span>
<span class="sd">        X may not contain (floating point) NaN values. Missing data may be</span>
<span class="sd">        specified using numpy masked arrays, as well as using standard</span>
<span class="sd">        numpy array/array-like objects; see below for details.</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X : numpy array (or array-like object such as a list of \</span>
<span class="sd">    immutables, as accepted by np.array())</span>
<span class="sd">        An array specifying the alphabet/alphabets of possible outcomes that</span>
<span class="sd">        random variable realisations in array X may assume. Defaults to None,</span>
<span class="sd">        in which case the alphabet/alphabets of possible outcomes is/are</span>
<span class="sd">        implicitly based the observed outcomes in array X, with no additional,</span>
<span class="sd">        unobserved outcomes. In combination with any estimator other than</span>
<span class="sd">        maximum likelihood, it may be useful to specify alphabets including</span>
<span class="sd">        unobserved outcomes. For such cases, successive possible outcomes of a</span>
<span class="sd">        random variable are indexed by the last axis in Alphabet_X; multiple</span>
<span class="sd">        alphabets may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1]. Alphabets of different sizes may</span>
<span class="sd">        be specified either using numpy masked arrays, or by padding with the</span>
<span class="sd">        chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying multiple alphabets, an alphabet of possible joint</span>
<span class="sd">        outcomes is always implicit from the alphabets of possible (marginal)</span>
<span class="sd">        outcomes in Alphabet_X. For example, specifying</span>
<span class="sd">        Alphabet_X=np.array(((1,2),(1,2))) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True, an additional dimension of length one is appended to</span>
<span class="sd">        the returned array, facilitating any broadcast operations required by</span>
<span class="sd">        the user (defaults to False).</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">)</span>
    <span class="n">H_joint</span> <span class="o">=</span> <span class="n">entropy_joint</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">)</span>

    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">-</span> <span class="n">H_joint</span>

    <span class="k">if</span> <span class="n">keep_dims</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">T</span></div>



<div class="viewcode-block" id="information_mutual_conditional">
<a class="viewcode-back" href="../index.html#discrete_random_variable.information_mutual_conditional">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">information_mutual_conditional</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="p">,</span>
    <span class="n">Z</span><span class="p">,</span>
    <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span>
    <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Alphabet_Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Alphabet_Z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the conditional mutual information (see e.g. [CoTh06]) between</span>
<span class="sd">    arrays X and Y given array Z, each containing discrete random variable</span>
<span class="sd">    realisations.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X`, :math:`Y`,  :math:`Z`, the</span>
<span class="sd">    conditional mutual information :math:`I(X;Y|Z)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        I(X;Y|Z) = H(X|Z) - H(X|Y,Z)</span>

<span class="sd">    where :math:`H(\\cdot|\\cdot)` denotes the conditional entropy.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Conditional mutual information is estimated based on frequency tables,</span>
<span class="sd">    using the following functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although</span>
<span class="sd">    conditional mutual information is a non-negative quantity, depending on the</span>
<span class="sd">    chosen estimator the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X,Y,Z : numpy array (or array-like object such as a list of immutables, \</span>
<span class="sd">    as accepted by np.array())</span>
<span class="sd">        *cartesian_product==False*: X,Y,Z are arrays containing discrete random</span>
<span class="sd">        variable realisations, with X.shape==Y.shape==Z.shape. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple random variables in X,Y,Z may be specified</span>
<span class="sd">        using preceding axes of the respective arrays (random variables are</span>
<span class="sd">        paired **one-to-one** between X,Y,Z). When X.ndim==Y.ndim==Z.ndim==1,</span>
<span class="sd">        returns a scalar. When X.ndim&gt;1 and Y.ndim&gt;1 and Z.ndim&gt;1, returns an</span>
<span class="sd">        array of estimated conditional mutual information values with</span>
<span class="sd">        dimensions X.shape[:-1]. Neither X nor Y nor Z may contain (floating</span>
<span class="sd">        point) NaN values. Missing data may be specified using numpy masked</span>
<span class="sd">        arrays, as well as using standard numpy array/array-like objects;</span>
<span class="sd">        see below for details.</span>

<span class="sd">        *cartesian_product==True*: X,Y,Z are arrays containing discrete random</span>
<span class="sd">        variable realisations, with X.shape[-1]==Y.shape[-1]==Z.shape[-1].</span>
<span class="sd">        Successive realisations of a random variable are indexed by the last</span>
<span class="sd">        axis in the respective arrays; multiple random variables in X,Y,Z may</span>
<span class="sd">        be specified using preceding axes of the respective arrays (random</span>
<span class="sd">        variables are paired **many-to-many** between X,Y,Z). When</span>
<span class="sd">        X.ndim==Y.ndim==Z.ndim==1, returns a scalar. When X.ndim&gt;1 or Y.ndim&gt;1</span>
<span class="sd">        or Z.ndim&gt;1, returns an array of estimated conditional mutual</span>
<span class="sd">        information values with dimensions</span>
<span class="sd">        np.append(X.shape[:-1],Y.shape[:-1],Z.shape[:-1]). Neither X nor Y nor</span>
<span class="sd">        Z may contain (floating point) NaN values. Missing data may be</span>
<span class="sd">        specified using numpy masked arrays, as well as using standard</span>
<span class="sd">        numpy array/array-like objects; see below for details.</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether random variables are paired **one-to-one** between</span>
<span class="sd">        X,Y,Z (cartesian_product==False, the default value) or **many-to-many**</span>
<span class="sd">        between X,Y,Z (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X, Alphabet_Y, Alphabet_Z : numpy array (or array-like object \</span>
<span class="sd">    such as a list of immutables, as accepted by np.array())</span>
<span class="sd">        Respectively an array specifying the alphabet/alphabets of possible</span>
<span class="sd">        outcomes that random variable realisations in array X, Y, Z may assume.</span>
<span class="sd">        Defaults to None, in which case the alphabet/alphabets of possible</span>
<span class="sd">        outcomes is/are implicitly based the observed outcomes in array X, Y, Z</span>
<span class="sd">        respectively, with no additional, unobserved outcomes. In combination</span>
<span class="sd">        with any estimator other than maximum likelihood, it may be useful to</span>
<span class="sd">        specify alphabets including unobserved outcomes. For such cases,</span>
<span class="sd">        successive possible outcomes of a random variable are indexed by the</span>
<span class="sd">        last axis in Alphabet_X, Alphabet_Y, Alphabet_Z respectively; multiple</span>
<span class="sd">        alphabets may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1] (analogously for Y and Z).</span>
<span class="sd">        Alphabets of different sizes may be specified either using numpy masked</span>
<span class="sd">        arrays, or by padding with the chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying alphabets, an alphabet of possible joint outcomes</span>
<span class="sd">        is always implicit from the alphabets of possible (marginal) outcomes</span>
<span class="sd">        in Alphabet_X, Alphabet_Y, Alphabet_Z. For example, specifying</span>
<span class="sd">        Alphabet_X=Alphabet_Y=Alphabet_Z=np.array(((1,2)) implies an alphabet</span>
<span class="sd">        of possible joint outcomes</span>
<span class="sd">        np.array((1,1,1,1,2,2,2,2),((1,1,2,2,1,1,2,2),(1,2,1,2,1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="n">Z</span><span class="p">,</span> <span class="n">fill_value_Z</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_Z</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Z</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_Z</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_Z</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_Z</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_Z</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Z</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">fill_value_Z</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Z</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Z contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Z contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Z</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Z contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_Z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Z contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_X</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg X is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_Y</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg Y is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_Z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg Z is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args X and Alphabet_X do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args Y and Alphabet_Y do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args Z and Alphabet_Z do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimensions of args X, Y, Z do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trailing dimensions of args X, Y, Z do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_map_observations_to_integers</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">Alphabet_Z</span><span class="p">),</span>
        <span class="p">(</span>
            <span class="n">fill_value_X</span><span class="p">,</span>
            <span class="n">fill_value_Alphabet_X</span><span class="p">,</span>
            <span class="n">fill_value_Y</span><span class="p">,</span>
            <span class="n">fill_value_Alphabet_Y</span><span class="p">,</span>
            <span class="n">fill_value_Z</span><span class="p">,</span>
            <span class="n">fill_value_Alphabet_Z</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">Alphabet_Z</span> <span class="o">=</span> <span class="n">S</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">I</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shapeI_Z</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">Alphabet_Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_Z</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">I</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">information_mutual_conditional</span><span class="p">(</span>
                    <span class="n">X</span><span class="p">,</span>
                    <span class="n">Y</span><span class="p">,</span>
                    <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="n">base</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="p">,</span>
                    <span class="n">estimator</span><span class="p">,</span>
                    <span class="n">Alphabet_X</span><span class="p">,</span>
                    <span class="n">Alphabet_Y</span><span class="p">,</span>
                    <span class="n">Alphabet_Z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="p">)</span>

            <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_cartesian_product_apply</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">))</span>
        <span class="n">shapeI_XY</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapeI_Z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shapeI_XY</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapeI_XY</span><span class="p">,</span> <span class="n">shapeI_Z</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">I</span>

    <span class="c1"># Re-shape H, X,Y,Z so that we may handle multi-dimensional arrays</span>
    <span class="c1"># equivalently and iterate across 0th axis</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_Z</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">orig_shape_I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">I_</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">entropy_joint</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span>
                <span class="n">base</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="p">,</span>
                <span class="n">estimator</span><span class="p">,</span>
                <span class="n">_vstack_pad</span><span class="p">((</span><span class="n">Alphabet_X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Alphabet_Z</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">fill_value</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="o">+</span> <span class="n">entropy_joint</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span>
                <span class="n">base</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="p">,</span>
                <span class="n">estimator</span><span class="p">,</span>
                <span class="n">_vstack_pad</span><span class="p">((</span><span class="n">Alphabet_Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Alphabet_Z</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">fill_value</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="o">-</span> <span class="n">entropy_joint</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span>
                <span class="n">base</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="p">,</span>
                <span class="n">estimator</span><span class="p">,</span>
                <span class="n">_vstack_pad</span><span class="p">((</span><span class="n">Alphabet_X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Alphabet_Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Alphabet_Z</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">fill_value</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="o">-</span> <span class="n">entropy_joint</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_Z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I_</span>

    <span class="c1"># Reverse re-shaping</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">orig_shape_I</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">I</span></div>



<div class="viewcode-block" id="information_lautum">
<a class="viewcode-back" href="../index.html#discrete_random_variable.information_lautum">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">information_lautum</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span>
    <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Alphabet_Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the lautum information [PaVe08] between arrays X and Y, each</span>
<span class="sd">    containing discrete random variable realisations.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P_X(x)`, :math:`P_Y(x)` respectively the probability</span>
<span class="sd">    of observing an outcome :math:`x` with discrete random variables :math:`X`,</span>
<span class="sd">    :math:`Y`, and denoting with :math:`P_{XY}(x,y)` the probability of jointly</span>
<span class="sd">    observing outcomes :math:`x`, :math:`y` respectively with :math:`X`,</span>
<span class="sd">    :math:`Y`, the lautum information :math:`L(X;Y)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \\begin{eqnarray}</span>
<span class="sd">            L(X;Y) &amp;=&amp; -\\sum_x \\sum_y</span>
<span class="sd">            {P_X(x) P_Y(y) \\log {\\frac{P_X(x) P_Y(y)}{P_{XY}(x,y)}}} \\\\</span>
<span class="sd">            &amp;=&amp; D_{\\mathrm{KL}}(P_X P_Y \\parallel P_{XY})</span>
<span class="sd">        \\end{eqnarray}</span>

<span class="sd">    where :math:`D_{\\mathrm{KL}}(\\cdot \\parallel \\cdot)` denotes the</span>
<span class="sd">    Kullback-Leibler divergence. Note that *lautum* is *mutual* spelt</span>
<span class="sd">    backwards; denoting with :math:`I(\\cdot;\\cdot)` the mutual information it</span>
<span class="sd">    may be shown (see e.g. [CoTh06]) that</span>

<span class="sd">    .. math::</span>
<span class="sd">        \\begin{eqnarray}</span>
<span class="sd">            I(X;Y) &amp;=&amp; D_{\\mathrm{KL}}(P_{XY} \\parallel P_X P_Y).</span>
<span class="sd">        \\end{eqnarray}</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Lautum information is estimated based on frequency tables. See below for a</span>
<span class="sd">    list of available estimators.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X,Y : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape[:-1]==Y.shape[:-1]. Successive realisations of a random</span>
<span class="sd">        variable are indexed by the last axis in the respective arrays;</span>
<span class="sd">        multiple random variables in X and Y may be specified using preceding</span>
<span class="sd">        axes of the respective arrays (random variables are paired</span>
<span class="sd">        **one-to-one** between X and Y). When X.ndim==Y.ndim==1, returns a</span>
<span class="sd">        scalar. When X.ndim&gt;1 and Y.ndim&gt;1, returns an array of estimated</span>
<span class="sd">        information values with dimensions X.shape[:-1]. Neither X nor Y may</span>
<span class="sd">        contain (floating point) NaN values. Missing data may be specified</span>
<span class="sd">        using numpy masked arrays, as well as using standard numpy</span>
<span class="sd">        array/array-like objects; see below for details.</span>

<span class="sd">        *cartesian_product==True and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple random variables in X and Y may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (random</span>
<span class="sd">        variables are paired **many-to-many** between X and Y). When</span>
<span class="sd">        X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 or Y.ndim&gt;1, returns</span>
<span class="sd">        an array of estimated information values with dimensions</span>
<span class="sd">        np.append(X.shape[:-1],Y.shape[:-1]). Neither X nor Y may contain</span>
<span class="sd">        (floating point) NaN values. Missing data may be specified using numpy</span>
<span class="sd">        masked arrays, as well as using standard numpy array/array-like</span>
<span class="sd">        objects; see below for details.</span>

<span class="sd">        *Y is None*: Equivalent to information_lautum(X, X, ... ). Thus, a</span>
<span class="sd">        shorthand syntax for computing lautum information (in bits) between all</span>
<span class="sd">        pairs of random variables in X is information_lautum(X).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y (cartesian_product==False, the default value) or **many-to-many**</span>
<span class="sd">        between X and Y (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X, Alphabet_Y : numpy array (or array-like object such as a list \</span>
<span class="sd">    of immutables, as accepted by np.array())</span>
<span class="sd">        Respectively an array specifying the alphabet/alphabets of possible</span>
<span class="sd">        outcomes that random variable realisations in array X, Y may assume.</span>
<span class="sd">        Defaults to None, in which case the alphabet/alphabets of possible</span>
<span class="sd">        outcomes is/are implicitly based the observed outcomes in array X, Y</span>
<span class="sd">        respectively, with no additional, unobserved outcomes. In combination</span>
<span class="sd">        with any estimator other than maximum likelihood, it may be useful to</span>
<span class="sd">        specify alphabets including unobserved outcomes. For such cases,</span>
<span class="sd">        successive possible outcomes of a random variable are indexed by the</span>
<span class="sd">        last axis in Alphabet_X, Alphabet_Y respectively; multiple alphabets</span>
<span class="sd">        may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1] (analogously for Y). Alphabets of</span>
<span class="sd">        different sizes may be specified either using numpy masked arrays, or</span>
<span class="sd">        by padding with the chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying alphabets, an alphabet of possible joint outcomes</span>
<span class="sd">        is always implicit from the alphabets of possible (marginal) outcomes</span>
<span class="sd">        in Alphabet_X, Alphabet_Y. For example, specifying</span>
<span class="sd">        Alphabet_X=Alphabet_Y=np.array(((1,2)) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">cartesian_product</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">Alphabet_X</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_X</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg X is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_Y</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg Y is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args X and Alphabet_X do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args Y and Alphabet_Y do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimensions of args X and Y do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trailing dimensions of args X and Y do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_map_observations_to_integers</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">),</span>
        <span class="p">(</span><span class="n">fill_value_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">S</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">H</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">information_lautum</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">_cartesian_product_apply</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">)</span>

    <span class="c1"># Re-shape H, X and Y, so that we may handle multi-dimensional arrays</span>
    <span class="c1"># equivalently and iterate across 0th axis</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">orig_shape_H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">_verify_alphabet_sufficiently_large</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="n">_verify_alphabet_sufficiently_large</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Sort X and Y jointly, so that we can determine joint symbol</span>
        <span class="c1"># probabilities</span>
        <span class="n">JointXY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">JointXY</span> <span class="o">=</span> <span class="n">JointXY</span><span class="p">[:,</span> <span class="n">JointXY</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)]</span>
        <span class="n">JointXY</span> <span class="o">=</span> <span class="n">JointXY</span><span class="p">[:,</span> <span class="n">JointXY</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)]</span>

        <span class="c1"># Compute symbol run-lengths</span>
        <span class="c1"># Compute symbol change indicators</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">JointXY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">JointXY</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Obtain symbol change positions</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">B</span><span class="p">),</span> <span class="n">JointXY</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Compute run lengths</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="p">))</span>

        <span class="n">alphabet_XY</span> <span class="o">=</span> <span class="n">JointXY</span><span class="p">[:,</span> <span class="n">I</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">estimator</span> <span class="o">!=</span> <span class="s2">&quot;ML&quot;</span><span class="p">:</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_XY</span> <span class="o">=</span> <span class="n">_append_empty_bins_using_alphabet</span><span class="p">(</span>
                <span class="n">L</span><span class="p">,</span>
                <span class="n">alphabet_XY</span><span class="p">,</span>
                <span class="n">_vstack_pad</span><span class="p">((</span><span class="n">Alphabet_X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Alphabet_Y</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">fill_value</span><span class="p">),</span>
                <span class="n">fill_value</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_XY</span> <span class="o">=</span> <span class="n">_remove_counts_at_fill_value</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">alphabet_XY</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">P_XY</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_estimate_probabilities</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">estimator</span><span class="p">)</span>

        <span class="c1"># Assign probabilities in P_XY to P_XY_reshaped, a matrix which</span>
        <span class="c1"># exhaustively records probabilities for all elements in the cartesian</span>
        <span class="c1"># product of alphabets. In this way, we can subsequently integrate</span>
        <span class="c1"># across variables X, Y.</span>
        <span class="n">alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">alphabet_XY</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">alphabet_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">alphabet_XY</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">P_XY_reshaped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">alphabet_Y</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">alphabet_X</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P_XY</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">alphabet_XY</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="n">alphabet_XY</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">alphabet_X</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">alphabet_XY</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">]:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">alphabet_Y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">alphabet_XY</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">]:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">P_XY_reshaped</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">P_XY</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

        <span class="c1"># Integrate across X, Y</span>
        <span class="n">P_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P_XY_reshaped</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">P_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P_XY_reshaped</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">divergence_kullbackleibler_pmf</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">P_X</span> <span class="o">*</span> <span class="n">P_Y</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">P_XY_reshaped</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="n">base</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Reverse re-shaping</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">orig_shape_H</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="information_mutual_normalised">
<a class="viewcode-back" href="../index.html#discrete_random_variable.information_mutual_normalised">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">information_mutual_normalised</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">norm_factor</span><span class="o">=</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span>
    <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span>
    <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Alphabet_Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># TODO Documentation should include properties for each of the</span>
    <span class="c1"># normalisation factors</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the normalised mutual information between arrays X and Y, each</span>
<span class="sd">    containing discrete random variable realisations.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X`, :math:`Y`, the normalised mutual</span>
<span class="sd">    information :math:`NI(X;Y)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        NI(X;Y) = \\frac{I(X;Y)}{C_n}</span>

<span class="sd">    where :math:`I` denotes the mutual information and where :math:`C_n`</span>
<span class="sd">    denotes a normalisation factor. Normalised mutual information is a</span>
<span class="sd">    dimensionless quantity, with :math:`C_n` alternatively defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">         \\begin{eqnarray}</span>
<span class="sd">           C_{\\text{X}} &amp;=&amp; H(X) \\\\</span>
<span class="sd">           C_{\\text{Y}} &amp;=&amp; H(Y) \\\\</span>
<span class="sd">           C_{\\text{X+Y}} &amp;=&amp; H(X) + H(Y) \\\\</span>
<span class="sd">           C_{\\text{MIN}} &amp;=&amp; \\min \{ H(X), H(Y) \} \\\\</span>
<span class="sd">           C_{\\text{MAX}} &amp;=&amp; \\max \{ H(X), H(Y) \} \\\\</span>
<span class="sd">           C_{\\text{XY}} &amp;=&amp; H(X,Y) \\\\</span>
<span class="sd">           C_{\\text{SQRT}} &amp;=&amp; \\sqrt{H(X) H(Y)}</span>
<span class="sd">         \\end{eqnarray}</span>

<span class="sd">    where :math:`H(\\cdot)` and :math:`H(\\cdot,\\cdot)` respectively denote</span>
<span class="sd">    the entropy and joint entropy.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Normalised mutual information is estimated based on frequency tables, using</span>
<span class="sd">    the following functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although normalised</span>
<span class="sd">    mutual information is a non-negative quantity, depending on the chosen</span>
<span class="sd">    estimator the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X,Y : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape==Y.shape. Successive realisations of a random variable are</span>
<span class="sd">        indexed by the last axis in the respective arrays; multiple random</span>
<span class="sd">        variables in X and Y may be specified using preceding axes of the</span>
<span class="sd">        respective arrays (random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y). When X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 and</span>
<span class="sd">        Y.ndim&gt;1, returns an array of estimated normalised information values</span>
<span class="sd">        with dimensions X.shape[:-1]. Neither X nor Y may contain (floating</span>
<span class="sd">        point) NaN values. Missing data may be specified using numpy masked</span>
<span class="sd">        arrays, as well as using standard numpy array/array-like objects;</span>
<span class="sd">        see below for details.</span>

<span class="sd">        *cartesian_product==True and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape[-1]==Y.shape[-1]. Successive realisations of a random variable</span>
<span class="sd">        are indexed by the last axis in the respective arrays; multiple random</span>
<span class="sd">        variables in X and Y may be specified using preceding axes of the</span>
<span class="sd">        respective arrays (random variables are paired **many-to-many** between</span>
<span class="sd">        X and Y). When X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 or</span>
<span class="sd">        Y.ndim&gt;1, returns an array of estimated normalised information values</span>
<span class="sd">        with dimensions np.append(X.shape[:-1],Y.shape[:-1]). Neither X nor Y</span>
<span class="sd">        may contain (floating point) NaN values. Missing data may be specified</span>
<span class="sd">        using numpy masked arrays, as well as using standard numpy</span>
<span class="sd">        array/array-like objects; see below for details.</span>

<span class="sd">        *Y is None*: Equivalent to information_mutual_normalised(X, X,</span>
<span class="sd">        norm_factor, True). Thus, a shorthand syntax for computing normalised</span>
<span class="sd">        mutual information (based on C_n = C_Y as defined above) between all</span>
<span class="sd">        pairs of random variables in X is information_mutual_normalised(X).</span>
<span class="sd">    norm_factor : string</span>
<span class="sd">        The desired normalisation factor, specified as a string. Internally,</span>
<span class="sd">        the supplied string is converted to upper case and spaces are</span>
<span class="sd">        discarded. Subsequently, the function tests for one of the following</span>
<span class="sd">        string values, each corresponding to an alternative normalisation</span>
<span class="sd">        factor as defined above:</span>

<span class="sd">        *&#39;X&#39;*</span>

<span class="sd">        *&#39;Y&#39; (the default value)*</span>

<span class="sd">        *&#39;X+Y&#39; (equivalently &#39;Y+X&#39;)*</span>

<span class="sd">        *&#39;MIN&#39;*</span>

<span class="sd">        *&#39;MAX&#39;*</span>

<span class="sd">        *&#39;XY&#39; (equivalently YX)*</span>

<span class="sd">        *&#39;SQRT&#39;*</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y (cartesian_product==False, the default value) or **many-to-many**</span>
<span class="sd">        between X and Y (cartesian_product==True).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X, Alphabet_Y : numpy array (or array-like object such as a list \</span>
<span class="sd">    of immutables, as accepted by np.array())</span>
<span class="sd">        Respectively an array specifying the alphabet/alphabets of possible</span>
<span class="sd">        outcomes that random variable realisations in array X, Y may assume.</span>
<span class="sd">        Defaults to None, in which case the alphabet/alphabets of possible</span>
<span class="sd">        outcomes is/are implicitly based the observed outcomes in array X, Y</span>
<span class="sd">        respectively, with no additional, unobserved outcomes. In combination</span>
<span class="sd">        with any estimator other than maximum likelihood, it may be useful to</span>
<span class="sd">        specify alphabets including unobserved outcomes. For such cases,</span>
<span class="sd">        successive possible outcomes of a random variable are indexed by the</span>
<span class="sd">        last axis in Alphabet_X, Alphabet_Y respectively; multiple alphabets</span>
<span class="sd">        may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1] (analogously for Y). Alphabets of</span>
<span class="sd">        different sizes may be specified either using numpy masked arrays, or</span>
<span class="sd">        by padding with the chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying alphabets, an alphabet of possible joint outcomes</span>
<span class="sd">        is always implicit from the alphabets of possible (marginal) outcomes</span>
<span class="sd">        in Alphabet_X, Alphabet_Y. For example, specifying</span>
<span class="sd">        Alphabet_X=Alphabet_Y=np.array(((1,2)) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">cartesian_product</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">Alphabet_X</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_X</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg X is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_Y</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg Y is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args X and Alphabet_X do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args Y and Alphabet_Y do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm_factor</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg norm_factor not a string&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimensions of args X and Y do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trailing dimensions of args X and Y do not match&quot;</span><span class="p">)</span>
    <span class="c1"># NB: No base parameter needed here, therefore no test!</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_map_observations_to_integers</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">),</span>
        <span class="p">(</span><span class="n">fill_value_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">S</span>

    <span class="n">I</span> <span class="o">=</span> <span class="n">information_mutual</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span>
        <span class="n">Y</span><span class="p">,</span>
        <span class="n">cartesian_product</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span>
        <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">Alphabet_X</span><span class="p">,</span>
        <span class="n">Alphabet_Y</span><span class="o">=</span><span class="n">Alphabet_Y</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">norm_factor</span> <span class="o">=</span> <span class="n">norm_factor</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm_factor</span> <span class="o">==</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span>
            <span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">Alphabet_Y</span>
        <span class="p">)</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">H2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H2</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">H2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">H2</span>
    <span class="k">elif</span> <span class="n">norm_factor</span> <span class="o">==</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
        <span class="n">H1</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">Alphabet_X</span>
        <span class="p">)</span>
        <span class="n">H1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">H1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H1</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">H1</span>
    <span class="k">elif</span> <span class="n">norm_factor</span> <span class="o">==</span> <span class="s2">&quot;Y+X&quot;</span> <span class="ow">or</span> <span class="n">norm_factor</span> <span class="o">==</span> <span class="s2">&quot;X+Y&quot;</span><span class="p">:</span>
        <span class="n">H1</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">Alphabet_X</span>
        <span class="p">)</span>
        <span class="n">H1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">H1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H1</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span>
            <span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">Alphabet_Y</span>
        <span class="p">)</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">H2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H2</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">H2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">H1</span> <span class="o">+</span> <span class="n">H2</span>
    <span class="k">elif</span> <span class="n">norm_factor</span> <span class="o">==</span> <span class="s2">&quot;MIN&quot;</span><span class="p">:</span>
        <span class="n">H1</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">Alphabet_X</span>
        <span class="p">)</span>
        <span class="n">H1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">H1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H1</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span>
            <span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">Alphabet_Y</span>
        <span class="p">)</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">H2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H2</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">H2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">H1</span><span class="p">,</span> <span class="n">H2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm_factor</span> <span class="o">==</span> <span class="s2">&quot;MAX&quot;</span><span class="p">:</span>
        <span class="n">H1</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">Alphabet_X</span>
        <span class="p">)</span>
        <span class="n">H1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">H1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H1</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span>
            <span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">Alphabet_Y</span>
        <span class="p">)</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">H2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H2</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">H2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">H1</span><span class="p">,</span> <span class="n">H2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm_factor</span> <span class="o">==</span> <span class="s2">&quot;XY&quot;</span> <span class="ow">or</span> <span class="n">norm_factor</span> <span class="o">==</span> <span class="s2">&quot;YX&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">H</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="c1"># Re-shape H and X, so that we may handle multi-dimensional arrays</span>
            <span class="c1"># equivalently and iterate across 0th axis</span>
            <span class="c1"># Re-shape X, so that we may handle multi-dimensional arrays</span>
            <span class="c1"># equivalently and iterate across 0th axis</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="c1"># Re-shape Y, so that we may handle multi-dimensional arrays</span>
            <span class="c1"># equivalently and iterate across 0th axis</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

            <span class="n">orig_shape_H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">entropy_joint</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                    <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span>
                    <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">_vstack_pad</span><span class="p">((</span><span class="n">Alphabet_X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Alphabet_Y</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">fill_value</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">orig_shape_H</span><span class="p">)</span>

            <span class="n">C</span> <span class="o">=</span> <span class="n">H</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">entropy_joint</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)),</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                    <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span>
                    <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">_vstack_pad</span><span class="p">((</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">),</span> <span class="n">fill_value</span><span class="p">),</span>
                <span class="p">)</span>

            <span class="n">H</span> <span class="o">=</span> <span class="n">_cartesian_product_apply</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">)</span>

            <span class="n">C</span> <span class="o">=</span> <span class="n">H</span>
    <span class="k">elif</span> <span class="n">norm_factor</span> <span class="o">==</span> <span class="s2">&quot;SQRT&quot;</span><span class="p">:</span>
        <span class="n">H1</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">Alphabet_X</span>
        <span class="p">)</span>
        <span class="n">H1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">H1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H1</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span>
            <span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="n">Alphabet_Y</span>
        <span class="p">)</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">H2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H2</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">H2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">H1</span> <span class="o">*</span> <span class="n">H2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg norm_factor has invalid value&quot;</span><span class="p">)</span>

    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span> <span class="o">/</span> <span class="n">C</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">I</span></div>



<div class="viewcode-block" id="information_variation">
<a class="viewcode-back" href="../index.html#discrete_random_variable.information_variation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">information_variation</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span>
    <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Alphabet_Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the variation of information [Meil03] between arrays X and Y, each</span>
<span class="sd">    containing discrete random variable realisations.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X`, :math:`Y`, the variation of</span>
<span class="sd">    information :math:`VI(X;Y)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        VI(X;Y) = H(X|Y) + H(Y|X)</span>

<span class="sd">    where :math:`H(\\cdot|\\cdot)` denotes the conditional entropy.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Variation of information is estimated based on frequency tables, using the</span>
<span class="sd">    following functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although variation</span>
<span class="sd">    of information is a non-negative quantity, depending on the chosen</span>
<span class="sd">    estimator the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X,Y : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape==Y.shape. Successive realisations of a random variable are</span>
<span class="sd">        indexed by the last axis in the respective arrays; multiple random</span>
<span class="sd">        variables in X and Y may be specified using preceding axes of the</span>
<span class="sd">        respective arrays (random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y). When X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 and</span>
<span class="sd">        Y.ndim&gt;1, returns an array of estimated information values with</span>
<span class="sd">        dimensions X.shape[:-1]. Neither X nor Y may contain (floating point)</span>
<span class="sd">        NaN values. Missing data may be specified using numpy masked arrays, as</span>
<span class="sd">        well as using standard numpy array/array-like objects; see below</span>
<span class="sd">        for details.</span>

<span class="sd">        *cartesian_product==True and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape[-1]==Y.shape[-1]. Successive realisations of a random variable</span>
<span class="sd">        are indexed by the last axis in the respective arrays; multiple random</span>
<span class="sd">        variables in X and Y may be specified using preceding axes of the</span>
<span class="sd">        respective arrays (random variables are paired **many-to-many** between</span>
<span class="sd">        X and Y). When X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 or</span>
<span class="sd">        Y.ndim&gt;1, returns an array of estimated information values with</span>
<span class="sd">        dimensions np.append(X.shape[:-1],Y.shape[:-1]). Neither X nor Y may</span>
<span class="sd">        contain (floating point) NaN values. Missing data may be specified</span>
<span class="sd">        using numpy masked arrays, as well as using standard numpy</span>
<span class="sd">        array/array-like objects; see below for details.</span>

<span class="sd">        *Y is None*: Equivalent to information_variation(X, X, ... ). Thus, a</span>
<span class="sd">        shorthand syntax for computing variation of information (in bits)</span>
<span class="sd">        between all pairs of random variables in X is information_variation(X).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y (cartesian_product==False, the default value) or **many-to-many**</span>
<span class="sd">        between X and Y (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X, Alphabet_Y : numpy array (or array-like object such as a list \</span>
<span class="sd">    of immutables, as accepted by np.array())</span>
<span class="sd">        Respectively an array specifying the alphabet/alphabets of possible</span>
<span class="sd">        outcomes that random variable realisations in array X, Y may assume.</span>
<span class="sd">        Defaults to None, in which case the alphabet/alphabets of possible</span>
<span class="sd">        outcomes is/are implicitly based the observed outcomes in array X, Y</span>
<span class="sd">        respectively, with no additional, unobserved outcomes. In combination</span>
<span class="sd">        with any estimator other than maximum likelihood, it may be useful to</span>
<span class="sd">        specify alphabets including unobserved outcomes. For such cases,</span>
<span class="sd">        successive possible outcomes of a random variable are indexed by the</span>
<span class="sd">        last axis in Alphabet_X, Alphabet_Y respectively; multiple alphabets</span>
<span class="sd">        may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1] (analogously for Y). Alphabets of</span>
<span class="sd">        different sizes may be specified either using numpy masked arrays, or</span>
<span class="sd">        by padding with the chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying alphabets, an alphabet of possible joint outcomes</span>
<span class="sd">        is always implicit from the alphabets of possible (marginal) outcomes</span>
<span class="sd">        in Alphabet_X, Alphabet_Y. For example, specifying</span>
<span class="sd">        Alphabet_X=Alphabet_Y=np.array(((1,2)) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">cartesian_product</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">Alphabet_X</span>

    <span class="n">H1</span> <span class="o">=</span> <span class="n">entropy_conditional</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span>
    <span class="p">)</span>
    <span class="n">H2</span> <span class="o">=</span> <span class="n">entropy_conditional</span><span class="p">(</span>
        <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">Alphabet_X</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">H2</span><span class="o">.</span><span class="n">T</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">H1</span> <span class="o">+</span> <span class="n">H2</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="information_mutual">
<a class="viewcode-back" href="../index.html#discrete_random_variable.information_mutual">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">information_mutual</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span>
    <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Alphabet_Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the mutual information (see e.g. [CoTh06]) between arrays X and Y,</span>
<span class="sd">    each containing discrete random variable realisations.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X`, :math:`Y`, the mutual</span>
<span class="sd">    information :math:`I(X;Y)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        I(X;Y) = H(X) - H(X|Y)</span>

<span class="sd">    where :math:`H(\\cdot)` denotes the entropy and where</span>
<span class="sd">    :math:`H(\\cdot|\\cdot)` denotes the conditional entropy.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Mutual information is estimated based on frequency tables, using the</span>
<span class="sd">    following functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although mutual</span>
<span class="sd">    information is a non-negative quantity, depending on the chosen estimator</span>
<span class="sd">    the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X,Y : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape==Y.shape. Successive realisations of a random variable are</span>
<span class="sd">        indexed by the last axis in the respective arrays; multiple random</span>
<span class="sd">        variables in X and Y may be specified using preceding axes of the</span>
<span class="sd">        respective arrays (random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y). When X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 and</span>
<span class="sd">        Y.ndim&gt;1, returns an array of estimated mutual information values with</span>
<span class="sd">        dimensions X.shape[:-1]. Neither X nor Y may contain (floating point)</span>
<span class="sd">        NaN values. Missing data may be specified using numpy masked arrays, as</span>
<span class="sd">        well as using standard numpy array/array-like objects; see below</span>
<span class="sd">        for details.</span>

<span class="sd">        *cartesian_product==True and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape[-1]==Y.shape[-1]. Successive realisations of a random variable</span>
<span class="sd">        are indexed by the last axis in the respective arrays; multiple random</span>
<span class="sd">        variables in X and Y may be specified using preceding axes of the</span>
<span class="sd">        respective arrays (random variables are paired **many-to-many** between</span>
<span class="sd">        X and Y). When X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 or</span>
<span class="sd">        Y.ndim&gt;1, returns an array of estimated mutual information values with</span>
<span class="sd">        dimensions np.append(X.shape[:-1],Y.shape[:-1]). Neither X nor Y may</span>
<span class="sd">        contain (floating point) NaN values. Missing data may be specified</span>
<span class="sd">        using numpy masked arrays, as well as using standard numpy</span>
<span class="sd">        array/array-like objects; see below for details.</span>

<span class="sd">        *Y is None*: Equivalent to information_mutual(X, X, ... ). Thus, a</span>
<span class="sd">        shorthand syntax for computing mutual information (in bits) between all</span>
<span class="sd">        pairs of random variables in X is information_mutual(X).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y (cartesian_product==False, the default value) or **many-to-many**</span>
<span class="sd">        between X and Y (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X, Alphabet_Y : numpy array (or array-like object such as a list \</span>
<span class="sd">    of immutables, as accepted by np.array())</span>
<span class="sd">        Respectively an array specifying the alphabet/alphabets of possible</span>
<span class="sd">        outcomes that random variable realisations in array X, Y may assume.</span>
<span class="sd">        Defaults to None, in which case the alphabet/alphabets of possible</span>
<span class="sd">        outcomes is/are implicitly based the observed outcomes in array X, Y</span>
<span class="sd">        respectively, with no additional, unobserved outcomes. In combination</span>
<span class="sd">        with any estimator other than maximum likelihood, it may be useful to</span>
<span class="sd">        specify alphabets including unobserved outcomes. For such cases,</span>
<span class="sd">        successive possible outcomes of a random variable are indexed by the</span>
<span class="sd">        last axis in Alphabet_X, Alphabet_Y respectively; multiple alphabets</span>
<span class="sd">        may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1] (analogously for Y). Alphabets of</span>
<span class="sd">        different sizes may be specified either using numpy masked arrays, or</span>
<span class="sd">        by padding with the chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying alphabets, an alphabet of possible joint outcomes</span>
<span class="sd">        is always implicit from the alphabets of possible (marginal) outcomes</span>
<span class="sd">        in Alphabet_X, Alphabet_Y. For example, specifying</span>
<span class="sd">        Alphabet_X=Alphabet_Y=np.array(((1,2)) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H_conditional</span> <span class="o">=</span> <span class="n">entropy_conditional</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span>
    <span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">)</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">H_conditional</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">-</span> <span class="n">H_conditional</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="entropy_cross">
<a class="viewcode-back" href="../index.html#discrete_random_variable.entropy_cross">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">entropy_cross</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span>
    <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Alphabet_Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the cross entropy (see e.g. [Murp12]) between arrays X and Y, each</span>
<span class="sd">    containing discrete random variable realisations.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P_X(x)`, :math:`P_Y(x)` respectively the probability</span>
<span class="sd">    of observing an outcome :math:`x` with discrete random variables :math:`X`,</span>
<span class="sd">    :math:`Y`, the cross entropy :math:`H^\\times(X,Y)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        H^\\times(X,Y) = -\\sum_x {P_X(x) \\log {P_Y(x)}}.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Cross entropy is estimated based on frequency tables. See below for a list</span>
<span class="sd">    of available estimators.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X,Y : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape[:-1]==Y.shape[:-1]. Successive realisations of a random</span>
<span class="sd">        variable are indexed by the last axis in the respective arrays;</span>
<span class="sd">        multiple random variables in X and Y may be specified using preceding</span>
<span class="sd">        axes of the respective arrays (random variables are paired</span>
<span class="sd">        **one-to-one** between X and Y). When X.ndim==Y.ndim==1, returns a</span>
<span class="sd">        scalar. When X.ndim&gt;1 and Y.ndim&gt;1, returns an array of estimated cross</span>
<span class="sd">        entropies with dimensions X.shape[:-1]. Neither X nor Y may contain</span>
<span class="sd">        (floating point) NaN values. Missing data may be specified using numpy</span>
<span class="sd">        masked arrays, as well as using standard numpy array/array-like</span>
<span class="sd">        objects; see below for details.</span>

<span class="sd">        *cartesian_product==True and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple random variables in X and Y may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (random</span>
<span class="sd">        variables are paired **many-to-many** between X and Y). When</span>
<span class="sd">        X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 or Y.ndim&gt;1, returns</span>
<span class="sd">        an array of estimated cross entropies with dimensions</span>
<span class="sd">        np.append(X.shape[:-1],Y.shape[:-1]). Neither X nor Y may contain</span>
<span class="sd">        (floating point) NaN values. Missing data may be specified using numpy</span>
<span class="sd">        masked arrays, as well as using standard numpy array/array-like</span>
<span class="sd">        objects; see below for details.</span>

<span class="sd">        *Y is None*: Equivalent to entropy_cross(X, X, ... ). Thus, a shorthand</span>
<span class="sd">        syntax for computing cross entropies (in bits) between all pairs of</span>
<span class="sd">        random variables in X is entropy_cross(X).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y (cartesian_product==False, the default value) or **many-to-many**</span>
<span class="sd">        between X and Y (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X, Alphabet_Y : numpy array (or array-like object such as a list \</span>
<span class="sd">    of immutables, as accepted by np.array())</span>
<span class="sd">        Respectively an array specifying the alphabet/alphabets of possible</span>
<span class="sd">        outcomes that random variable realisations in array X, Y may assume.</span>
<span class="sd">        Defaults to None, in which case the alphabet/alphabets of possible</span>
<span class="sd">        outcomes is/are implicitly based the observed outcomes in array X, Y</span>
<span class="sd">        respectively, with no additional, unobserved outcomes. In combination</span>
<span class="sd">        with any estimator other than maximum likelihood, it may be useful to</span>
<span class="sd">        specify alphabets including unobserved outcomes. For such cases,</span>
<span class="sd">        successive possible outcomes of a random variable are indexed by the</span>
<span class="sd">        last axis in Alphabet_X, Alphabet_Y respectively; multiple alphabets</span>
<span class="sd">        may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1] (analogously for Y). Alphabets of</span>
<span class="sd">        different sizes may be specified either using numpy masked arrays, or</span>
<span class="sd">        by padding with the chosen placeholder fill_value.</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">cartesian_product</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">Alphabet_X</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_X</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg X is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_Y</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg Y is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args X and Alphabet_X do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args Y and Alphabet_Y do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimensions of args X and Y do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_map_observations_to_integers</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">),</span>
        <span class="p">(</span><span class="n">fill_value_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">S</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">H</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">entropy_cross</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">_cartesian_product_apply</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">)</span>

    <span class="c1"># Re-shape H, X and Y, so that we may handle multi-dimensional arrays</span>
    <span class="c1"># equivalently and iterate across 0th axis</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">orig_shape_H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">_verify_alphabet_sufficiently_large</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="n">_verify_alphabet_sufficiently_large</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

    <span class="c1"># NB: Observations are not considered jointly, thus elements in each row</span>
    <span class="c1"># are sorted independently</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Compute symbol run-lengths</span>
    <span class="c1"># Compute symbol change indicators</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">Y</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Obtain symbol change positions</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Compute run lengths</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="p">))</span>

        <span class="n">alphabet_X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">I</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">estimator</span> <span class="o">!=</span> <span class="s2">&quot;ML&quot;</span><span class="p">:</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span> <span class="o">=</span> <span class="n">_append_empty_bins_using_alphabet</span><span class="p">(</span>
                <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fill_value</span>
            <span class="p">)</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span> <span class="o">=</span> <span class="n">_remove_counts_at_fill_value</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">P1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_estimate_probabilities</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">estimator</span><span class="p">)</span>

        <span class="c1"># Obtain symbol change positions</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Compute run lengths</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">J</span><span class="p">))</span>

        <span class="n">alphabet_Y</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">J</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">estimator</span> <span class="o">!=</span> <span class="s2">&quot;ML&quot;</span><span class="p">:</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_Y</span> <span class="o">=</span> <span class="n">_append_empty_bins_using_alphabet</span><span class="p">(</span>
                <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fill_value</span>
            <span class="p">)</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_Y</span> <span class="o">=</span> <span class="n">_remove_counts_at_fill_value</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">alphabet_Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">P2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_estimate_probabilities</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">estimator</span><span class="p">)</span>

        <span class="c1"># Merge probability distributions, so that common symbols have common</span>
        <span class="c1"># array location</span>
        <span class="n">Alphabet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">alphabet_X</span><span class="p">,</span> <span class="n">alphabet_Y</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">P1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">P2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">P</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">,</span> <span class="n">alphabet_X</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span> <span class="o">=</span> <span class="n">P1</span>
        <span class="n">Q</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">,</span> <span class="n">alphabet_Y</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span> <span class="o">=</span> <span class="n">P2</span>

        <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">entropy_cross_pmf</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>

    <span class="c1"># Reverse re-shaping</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">orig_shape_H</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="divergence_kullbackleibler">
<a class="viewcode-back" href="../index.html#discrete_random_variable.divergence_kullbackleibler">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">divergence_kullbackleibler</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span>
    <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Alphabet_Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the Kullback-Leibler divergence (see e.g. [CoTh06]) between arrays</span>
<span class="sd">    X and Y, each containing discrete random variable realisations.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P_X(x)`, :math:`P_Y(x)` respectively the probability</span>
<span class="sd">    of observing an outcome :math:`x` with discrete random variables :math:`X`,</span>
<span class="sd">    :math:`Y`, the Kullback-Leibler divergence</span>
<span class="sd">    :math:`D_{\\mathrm{KL}}(P_X\\parallel P_Y)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        D_{\\mathrm{KL}}(P_X \\parallel P_Y) =</span>
<span class="sd">        -\\sum_x {P_X(x) \\log {\\frac{P_Y(x)}{P_X(x)}}}.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Kullback-Leibler divergence is estimated based on frequency tables, using</span>
<span class="sd">    the following functions:</span>

<span class="sd">        entropy_cross()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although</span>
<span class="sd">    Kullback-Leibler divergence is a non-negative quantity, depending on the</span>
<span class="sd">    chosen estimator the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X,Y : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape[:-1]==Y.shape[:-1]. Successive realisations of a random</span>
<span class="sd">        variable are indexed by the last axis in the respective arrays;</span>
<span class="sd">        multiple random variables in X and Y may be specified using preceding</span>
<span class="sd">        axes of the respective arrays (random variables are paired</span>
<span class="sd">        **one-to-one** between X and Y). When X.ndim==Y.ndim==1, returns a</span>
<span class="sd">        scalar. When X.ndim&gt;1 and Y.ndim&gt;1, returns an array of estimated</span>
<span class="sd">        divergence values with dimensions X.shape[:-1]. Neither X nor Y may</span>
<span class="sd">        contain (floating point) NaN values. Missing data may be specified</span>
<span class="sd">        using numpy masked arrays, as well as using standard numpy</span>
<span class="sd">        array/array-like objects; see below for details.</span>

<span class="sd">        *cartesian_product==True and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple random variables in X and Y may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (random</span>
<span class="sd">        variables are paired **many-to-many** between X and Y). When</span>
<span class="sd">        X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 or Y.ndim&gt;1, returns</span>
<span class="sd">        an array of estimated divergence values with dimensions</span>
<span class="sd">        np.append(X.shape[:-1],Y.shape[:-1]). Neither X nor Y may contain</span>
<span class="sd">        (floating point) NaN values. Missing data may be specified using numpy</span>
<span class="sd">        masked arrays, as well as using standard numpy array/array-like</span>
<span class="sd">        objects; see below for details.</span>

<span class="sd">        *Y is None*: Equivalent to divergence_kullbackleibler(X, X, ... ).</span>
<span class="sd">        Thus, a shorthand syntax for computing Kullback-Leibler divergence (in</span>
<span class="sd">        bits) between all pairs of random variables in X is</span>
<span class="sd">        divergence_kullbackleibler(X).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y (cartesian_product==False, the default value) or **many-to-many**</span>
<span class="sd">        between X and Y (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X, Alphabet_Y : numpy array (or array-like object such as a list \</span>
<span class="sd">    of immutables, as accepted by np.array())</span>
<span class="sd">        Respectively an array specifying the alphabet/alphabets of possible</span>
<span class="sd">        outcomes that random variable realisations in array X, Y may assume.</span>
<span class="sd">        Defaults to None, in which case the alphabet/alphabets of possible</span>
<span class="sd">        outcomes is/are implicitly based the observed outcomes in array X, Y</span>
<span class="sd">        respectively, with no additional, unobserved outcomes. In combination</span>
<span class="sd">        with any estimator other than maximum likelihood, it may be useful to</span>
<span class="sd">        specify alphabets including unobserved outcomes. For such cases,</span>
<span class="sd">        successive possible outcomes of a random variable are indexed by the</span>
<span class="sd">        last axis in Alphabet_X, Alphabet_Y respectively; multiple alphabets</span>
<span class="sd">        may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1] (analogously for Y). Alphabets of</span>
<span class="sd">        different sizes may be specified either using numpy masked arrays, or</span>
<span class="sd">        by padding with the chosen placeholder fill_value.</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H_cross</span> <span class="o">=</span> <span class="n">entropy_cross</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span>
    <span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">)</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">H_cross</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">H_cross</span> <span class="o">-</span> <span class="n">H</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="divergence_jensenshannon">
<a class="viewcode-back" href="../index.html#discrete_random_variable.divergence_jensenshannon">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">divergence_jensenshannon</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span>
    <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Alphabet_Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the Jensen-Shannon divergence [Lin91] between arrays X and Y, each</span>
<span class="sd">    containing discrete random variable realisations.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P_X`, :math:`P_Y` respectively probability</span>
<span class="sd">    distributions with common domain, associated with discrete random variables</span>
<span class="sd">    :math:`X`, :math:`Y`, the Jensen-Shannon divergence</span>
<span class="sd">    :math:`D_{\\mathrm{JS}}(P_X \\parallel P_Y)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        D_{\\mathrm{JS}}(P_X \\parallel P_Y) =</span>
<span class="sd">        \\frac{1}{2} D_{\\mathrm{KL}}(P_X \\parallel M) +</span>
<span class="sd">        \\frac{1}{2} D_{\\mathrm{KL}}(P_Y \\parallel M)</span>

<span class="sd">    where :math:`M = \\frac{1}{2}(P_X + P_Y)` and where</span>
<span class="sd">    :math:`D_{\\mathrm{KL}}(\\cdot \\parallel \\cdot)` denotes the</span>
<span class="sd">    Kullback-Leibler divergence.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Jensen-Shannon divergence is estimated based on frequency tables. See below</span>
<span class="sd">    for a list of available estimators.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X,Y : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape[:-1]==Y.shape[:-1]. Successive realisations of a random</span>
<span class="sd">        variable are indexed by the last axis in the respective arrays;</span>
<span class="sd">        multiple random variables in X and Y may be specified using preceding</span>
<span class="sd">        axes of the respective arrays (random variables are paired</span>
<span class="sd">        **one-to-one** between X and Y). When X.ndim==Y.ndim==1, returns a</span>
<span class="sd">        scalar. When X.ndim&gt;1 and Y.ndim&gt;1, returns an array of estimated</span>
<span class="sd">        divergence values with dimensions X.shape[:-1]. Neither X nor Y may</span>
<span class="sd">        contain (floating point) NaN values. Missing data may be specified</span>
<span class="sd">        using numpy masked arrays, as well as using standard numpy</span>
<span class="sd">        array/array-like objects; see below for details.</span>

<span class="sd">        *cartesian_product==True and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple random variables in X and Y may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (random</span>
<span class="sd">        variables are paired **many-to-many** between X and Y). When</span>
<span class="sd">        X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 or Y.ndim&gt;1, returns</span>
<span class="sd">        an array of estimated divergence values with dimensions</span>
<span class="sd">        np.append(X.shape[:-1],Y.shape[:-1]). Neither X nor Y may contain</span>
<span class="sd">        (floating point) NaN values. Missing data may be specified using numpy</span>
<span class="sd">        masked arrays, as well as using standard numpy array/array-like</span>
<span class="sd">        objects; see below for details.</span>

<span class="sd">        *Y is None*: Equivalent to divergence_jensenshannon(X, X, ... ). Thus,</span>
<span class="sd">        a shorthand syntax for computing Jensen-Shannon divergence (in bits)</span>
<span class="sd">        between all pairs of random variables in X is</span>
<span class="sd">        divergence_jensenshannon(X).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y (cartesian_product==False, the default value) or **many-to-many**</span>
<span class="sd">        between X and Y (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X, Alphabet_Y : numpy array (or array-like object such as a list \</span>
<span class="sd">    of immutables, as accepted by np.array())</span>
<span class="sd">        Respectively an array specifying the alphabet/alphabets of possible</span>
<span class="sd">        outcomes that random variable realisations in array X, Y may assume.</span>
<span class="sd">        Defaults to None, in which case the alphabet/alphabets of possible</span>
<span class="sd">        outcomes is/are implicitly based the observed outcomes in array X, Y</span>
<span class="sd">        respectively, with no additional, unobserved outcomes. In combination</span>
<span class="sd">        with any estimator other than maximum likelihood, it may be useful to</span>
<span class="sd">        specify alphabets including unobserved outcomes. For such cases,</span>
<span class="sd">        successive possible outcomes of a random variable are indexed by the</span>
<span class="sd">        last axis in Alphabet_X, Alphabet_Y respectively; multiple alphabets</span>
<span class="sd">        may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1] (analogously for Y). Alphabets of</span>
<span class="sd">        different sizes may be specified either using numpy masked arrays, or</span>
<span class="sd">        by padding with the chosen placeholder fill_value.</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">cartesian_product</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">Alphabet_X</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_X</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg X is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_Y</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg Y is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args X and Alphabet_X do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args Y and Alphabet_Y do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimensions of args X and Y do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_map_observations_to_integers</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">),</span>
        <span class="p">(</span><span class="n">fill_value_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">S</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">H</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">divergence_jensenshannon</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">_cartesian_product_apply</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">)</span>

    <span class="c1"># Re-shape H, X and Y, so that we may handle multi-dimensional arrays</span>
    <span class="c1"># equivalently and iterate across 0th axis</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">orig_shape_H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">_verify_alphabet_sufficiently_large</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="n">_verify_alphabet_sufficiently_large</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

    <span class="c1"># NB: Observations are not considered jointly, thus elements in each row</span>
    <span class="c1"># are sorted independently</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Compute symbol run-lengths</span>
    <span class="c1"># Compute symbol change indicators</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">Y</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Obtain symbol change positions</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Compute run lengths</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="p">))</span>

        <span class="n">alphabet_X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">I</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">estimator</span> <span class="o">!=</span> <span class="s2">&quot;ML&quot;</span><span class="p">:</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span> <span class="o">=</span> <span class="n">_append_empty_bins_using_alphabet</span><span class="p">(</span>
                <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fill_value</span>
            <span class="p">)</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span> <span class="o">=</span> <span class="n">_remove_counts_at_fill_value</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">P1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_estimate_probabilities</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">estimator</span><span class="p">)</span>

        <span class="c1"># Obtain symbol change positions</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Compute run lengths</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">J</span><span class="p">))</span>

        <span class="n">alphabet_Y</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">J</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">estimator</span> <span class="o">!=</span> <span class="s2">&quot;ML&quot;</span><span class="p">:</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_Y</span> <span class="o">=</span> <span class="n">_append_empty_bins_using_alphabet</span><span class="p">(</span>
                <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fill_value</span>
            <span class="p">)</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_Y</span> <span class="o">=</span> <span class="n">_remove_counts_at_fill_value</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">alphabet_Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">P2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_estimate_probabilities</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">estimator</span><span class="p">)</span>

        <span class="c1"># Merge probability distributions, so that common symbols have common</span>
        <span class="c1"># array location</span>
        <span class="n">Alphabet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">alphabet_X</span><span class="p">,</span> <span class="n">alphabet_Y</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">P1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">P2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">P</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">,</span> <span class="n">alphabet_X</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span> <span class="o">=</span> <span class="n">P1</span>
        <span class="n">Q</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">,</span> <span class="n">alphabet_Y</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span> <span class="o">=</span> <span class="n">P2</span>

        <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">entropy_pmf</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">P</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">Q</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">entropy_pmf</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">entropy_pmf</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Reverse re-shaping</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">orig_shape_H</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="divergence_kullbackleibler_symmetrised">
<a class="viewcode-back" href="../index.html#discrete_random_variable.divergence_kullbackleibler_symmetrised">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">divergence_kullbackleibler_symmetrised</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span>
    <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Alphabet_Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the symmetrised Kullback-Leibler divergence [Lin91] between arrays</span>
<span class="sd">    X and Y, each containing discrete random variable realisations.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P_X`, :math:`P_Y` respectively probability</span>
<span class="sd">    distributions with common domain, associated with discrete random variables</span>
<span class="sd">    :math:`X`, :math:`Y`, the symmetrised Kullback-Leibler divergence</span>
<span class="sd">    :math:`D_{\\mathrm{SKL}}(P_X \\parallel P_Y)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        D_{\\mathrm{SKL}}(P_X \\parallel P_Y) =</span>
<span class="sd">        D_{\\mathrm{KL}}(P_X \\parallel P_Y) +</span>
<span class="sd">        D_{\\mathrm{KL}}(P_Y \\parallel P_X)</span>

<span class="sd">    where :math:`D_{\\mathrm{KL}}(\\cdot \\parallel \\cdot)` denotes the</span>
<span class="sd">    Kullback-Leibler divergence.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Symmetrised Kullback-Leibler divergence is estimated based on frequency</span>
<span class="sd">    tables, using the following functions:</span>

<span class="sd">        entropy_cross()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although</span>
<span class="sd">    symmetrised Kullback-Leibler divergence is a non-negative quantity,</span>
<span class="sd">    depending on the chosen estimator the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X,Y : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape[:-1]==Y.shape[:-1]. Successive realisations of a random</span>
<span class="sd">        variable are indexed by the last axis in the respective arrays;</span>
<span class="sd">        multiple random variables in X and Y may be specified using preceding</span>
<span class="sd">        axes of the respective arrays (random variables are paired</span>
<span class="sd">        **one-to-one** between X and Y). When X.ndim==Y.ndim==1, returns a</span>
<span class="sd">        scalar. When X.ndim&gt;1 and Y.ndim&gt;1, returns an array of estimated</span>
<span class="sd">        divergence values with dimensions X.shape[:-1]. Neither X nor Y may</span>
<span class="sd">        contain (floating point) NaN values. Missing data may be specified</span>
<span class="sd">        using numpy masked arrays, as well as using standard numpy</span>
<span class="sd">        array/array-like objects; see below for details.</span>

<span class="sd">        *cartesian_product==True and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple random variables in X and Y may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (random</span>
<span class="sd">        variables are paired **many-to-many** between X and Y). When</span>
<span class="sd">        X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 or Y.ndim&gt;1, returns</span>
<span class="sd">        an array of estimated divergence values with dimensions</span>
<span class="sd">        np.append(X.shape[:-1],Y.shape[:-1]). Neither X nor Y may contain</span>
<span class="sd">        (floating point) NaN values. Missing data may be specified using numpy</span>
<span class="sd">        masked arrays, as well as using standard numpy array/array-like</span>
<span class="sd">        objects; see below for details.</span>

<span class="sd">        *Y is None*: Equivalent to divergence_kullbackleibler_symmetrised(X, X,</span>
<span class="sd">        ... ). Thus, a shorthand syntax for computing symmetrised</span>
<span class="sd">        Kullback-Leibler divergence (in bits) between all pairs of random</span>
<span class="sd">        variables in X is divergence_kullbackleibler_symmetrised(X).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y (cartesian_product==False, the default value) or **many-to-many**</span>
<span class="sd">        between X and Y (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X, Alphabet_Y : numpy array (or array-like object such as a list \</span>
<span class="sd">    of immutables, as accepted by np.array())</span>
<span class="sd">        Respectively an array specifying the alphabet/alphabets of possible</span>
<span class="sd">        outcomes that random variable realisations in array X, Y may assume.</span>
<span class="sd">        Defaults to None, in which case the alphabet/alphabets of possible</span>
<span class="sd">        outcomes is/are implicitly based the observed outcomes in array X, Y</span>
<span class="sd">        respectively, with no additional, unobserved outcomes. In combination</span>
<span class="sd">        with any estimator other than maximum likelihood, it may be useful to</span>
<span class="sd">        specify alphabets including unobserved outcomes. For such cases,</span>
<span class="sd">        successive possible outcomes of a random variable are indexed by the</span>
<span class="sd">        last axis in Alphabet_X, Alphabet_Y respectively; multiple alphabets</span>
<span class="sd">        may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1] (analogously for Y). Alphabets of</span>
<span class="sd">        different sizes may be specified either using numpy masked arrays, or</span>
<span class="sd">        by padding with the chosen placeholder fill_value.</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">cartesian_product</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">Alphabet_X</span>

    <span class="n">H1</span> <span class="o">=</span> <span class="n">divergence_kullbackleibler</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span>
    <span class="p">)</span>
    <span class="n">H2</span> <span class="o">=</span> <span class="n">divergence_kullbackleibler</span><span class="p">(</span>
        <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">Alphabet_X</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">H2</span><span class="o">.</span><span class="n">T</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">H1</span> <span class="o">+</span> <span class="n">H2</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="entropy_conditional">
<a class="viewcode-back" href="../index.html#discrete_random_variable.entropy_conditional">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">entropy_conditional</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span>
    <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Alphabet_Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the conditional entropy (see e.g. [CoTh06]) between arrays X and Y,</span>
<span class="sd">    each containing discrete random variable realisations.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Given discrete random variables :math:`X`, :math:`Y`, the conditional</span>
<span class="sd">    entropy :math:`H(X|Y)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        H(X|Y) = H(X,Y) - H(Y)</span>

<span class="sd">    where :math:`H(\\cdot,\\cdot)` denotes the joint entropy and where</span>
<span class="sd">    :math:`H(\\cdot)` denotes the entropy.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Conditional entropy is estimated based on frequency tables, using the</span>
<span class="sd">    following functions:</span>

<span class="sd">        entropy_joint()</span>

<span class="sd">        entropy()</span>

<span class="sd">    See below for a list of available estimators. Note that although</span>
<span class="sd">    conditional entropy is a non-negative quantity, depending on the chosen</span>
<span class="sd">    estimator the obtained estimate may be negative.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X,Y : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape==Y.shape. Successive realisations of a random variable are</span>
<span class="sd">        indexed by the last axis in the respective arrays; multiple random</span>
<span class="sd">        variables in X and Y may be specified using preceding axes of the</span>
<span class="sd">        respective arrays (random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y). When X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 and</span>
<span class="sd">        Y.ndim&gt;1, returns an array of estimated conditional entropies with</span>
<span class="sd">        dimensions X.shape[:-1]. Neither X nor Y may contain (floating point)</span>
<span class="sd">        NaN values. Missing data may be specified using numpy masked arrays, as</span>
<span class="sd">        well as using standard numpy array/array-like objects; see below</span>
<span class="sd">        for details.</span>

<span class="sd">        *cartesian_product==True and Y is not None*: X and Y are arrays</span>
<span class="sd">        containing discrete random variable realisations, with</span>
<span class="sd">        X.shape[-1]==Y.shape[-1]. Successive realisations of a random variable</span>
<span class="sd">        are indexed by the last axis in the respective arrays; multiple random</span>
<span class="sd">        variables in X and Y may be specified using preceding axes of the</span>
<span class="sd">        respective arrays (random variables are paired **many-to-many** between</span>
<span class="sd">        X and Y). When X.ndim==Y.ndim==1, returns a scalar. When X.ndim&gt;1 or</span>
<span class="sd">        Y.ndim&gt;1, returns an array of estimated conditional entropies with</span>
<span class="sd">        dimensions np.append(X.shape[:-1],Y.shape[:-1]). Neither X nor Y may</span>
<span class="sd">        contain (floating point) NaN values. Missing data may be specified</span>
<span class="sd">        using numpy masked arrays, as well as using standard numpy</span>
<span class="sd">        array/array-like objects; see below for details.</span>

<span class="sd">        *Y is None*: Equivalent to entropy_conditional(X, X, ... ). Thus, a</span>
<span class="sd">        shorthand syntax for computing conditional entropies (in bits) between</span>
<span class="sd">        all pairs of random variables in X is entropy_conditional(X).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether random variables are paired **one-to-one** between X</span>
<span class="sd">        and Y (cartesian_product==False, the default value) or **many-to-many**</span>
<span class="sd">        between X and Y (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X, Alphabet_Y : numpy array (or array-like object such as a list \</span>
<span class="sd">    of immutables, as accepted by np.array())</span>
<span class="sd">        Respectively an array specifying the alphabet/alphabets of possible</span>
<span class="sd">        outcomes that random variable realisations in array X, Y may assume.</span>
<span class="sd">        Defaults to None, in which case the alphabet/alphabets of possible</span>
<span class="sd">        outcomes is/are implicitly based the observed outcomes in array X, Y</span>
<span class="sd">        respectively, with no additional, unobserved outcomes. In combination</span>
<span class="sd">        with any estimator other than maximum likelihood, it may be useful to</span>
<span class="sd">        specify alphabets including unobserved outcomes. For such cases,</span>
<span class="sd">        successive possible outcomes of a random variable are indexed by the</span>
<span class="sd">        last axis in Alphabet_X, Alphabet_Y respectively; multiple alphabets</span>
<span class="sd">        may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1] (analogously for Y). Alphabets of</span>
<span class="sd">        different sizes may be specified either using numpy masked arrays, or</span>
<span class="sd">        by padding with the chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying alphabets, an alphabet of possible joint outcomes</span>
<span class="sd">        is always implicit from the alphabets of possible (marginal) outcomes</span>
<span class="sd">        in Alphabet_X, Alphabet_Y. For example, specifying</span>
<span class="sd">        Alphabet_X=Alphabet_Y=np.array(((1,2)) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO Add note in documentation (for other functions where appropriate)</span>
    <span class="c1"># about creating joint observations using appropriate function</span>
    <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">cartesian_product</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">Alphabet_X</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">fill_value_Y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_Y contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_X</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg X is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_Y</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg Y is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args X and Alphabet_X do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args Y and Alphabet_Y do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimensions of args X and Y do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trailing dimensions of args X and Y do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_map_observations_to_integers</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">),</span>
        <span class="p">(</span><span class="n">fill_value_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Y</span><span class="p">,</span> <span class="n">fill_value_Alphabet_Y</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">S</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">H</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">entropy_conditional</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">_cartesian_product_apply</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">)</span>

    <span class="c1"># Re-shape H, X and Y, so that we may handle multi-dimensional arrays</span>
    <span class="c1"># equivalently and iterate across 0th axis</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">orig_shape_H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">entropy_joint</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span>
            <span class="n">base</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="p">,</span>
            <span class="n">estimator</span><span class="p">,</span>
            <span class="n">_vstack_pad</span><span class="p">((</span><span class="n">Alphabet_X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Alphabet_Y</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">fill_value</span><span class="p">),</span>
        <span class="p">)</span> <span class="o">-</span> <span class="n">entropy</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">base</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Reverse re-shaping</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">orig_shape_H</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="entropy_joint">
<a class="viewcode-back" href="../index.html#discrete_random_variable.entropy_joint">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">entropy_joint</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the estimated joint entropy (see e.g. [CoTh06]) for an array X</span>
<span class="sd">    containing realisations of discrete random variables.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P(x_1, \\ldots, x_n)` the probability of jointly</span>
<span class="sd">    observing outcomes :math:`(x_1, \\ldots, x_n)` of :math:`n` discrete random</span>
<span class="sd">    variables :math:`(X_1, \ldots, X_n)`, the joint entropy</span>
<span class="sd">    :math:`H(X_1, \\ldots, X_n)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        H(X_1, \\ldots, X_n) = -\\sum_{x_1} \\ldots \\sum_{x_n}</span>
<span class="sd">        {P(x_1, \\ldots, x_n ) \\log {P(x_1, \\ldots, x_n)}}.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Joint entropy is estimated based on frequency tables. See below for a list</span>
<span class="sd">    of available estimators.</span>

<span class="sd">    *Parameters**:</span>

<span class="sd">    X : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        An array containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        array; multiple random variables may be specified using preceding axes.</span>
<span class="sd">        When X.ndim==1, returns a scalar and is equivalent to entropy(). When</span>
<span class="sd">        X.ndim&gt;1, returns a scalar based on jointly considering all random</span>
<span class="sd">        variables indexed in the array. X may not contain (floating point) NaN</span>
<span class="sd">        values. Missing data may be specified using numpy masked arrays, as</span>
<span class="sd">        well as using standard numpy array/array-like objects; see below</span>
<span class="sd">        for details.</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X : numpy array (or array-like object such as a list of \</span>
<span class="sd">    immutables, as accepted by np.array())</span>
<span class="sd">        An array specifying the alphabet/alphabets of possible outcomes that</span>
<span class="sd">        random variable realisations in array X may assume. Defaults to None,</span>
<span class="sd">        in which case the alphabet/alphabets of possible outcomes is/are</span>
<span class="sd">        implicitly based the observed outcomes in array X, with no additional,</span>
<span class="sd">        unobserved outcomes. In combination with any estimator other than</span>
<span class="sd">        maximum likelihood, it may be useful to specify alphabets including</span>
<span class="sd">        unobserved outcomes. For such cases, successive possible outcomes of a</span>
<span class="sd">        random variable are indexed by the last axis in Alphabet_X; multiple</span>
<span class="sd">        alphabets may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1]. Alphabets of different sizes may</span>
<span class="sd">        be specified either using numpy masked arrays, or by padding with the</span>
<span class="sd">        chosen placeholder fill_value.</span>

<span class="sd">        NB: When specifying multiple alphabets, an alphabet of possible joint</span>
<span class="sd">        outcomes is always implicit from the alphabets of possible (marginal)</span>
<span class="sd">        outcomes in Alphabet_X. For example, specifying</span>
<span class="sd">        Alphabet_X=np.array(((1,2),(1,2))) implies an alphabet of possible</span>
<span class="sd">        joint outcomes np.array(((1,1,2,2),(1,2,1,2))).</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True, an additional dimension of length one is appended to</span>
<span class="sd">        the returned array, facilitating any broadcast operations required by</span>
<span class="sd">        the user (defaults to False).</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO If we add joint observation function, we can reduce code duplication</span>
    <span class="c1"># in this function.</span>
    <span class="c1"># TODO NB: The joint observation function must honour missing data fill</span>
    <span class="c1"># values.</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_X</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg X is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args X and Alphabet_X do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_map_observations_to_integers</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">),</span> <span class="p">(</span><span class="n">fill_value_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">S</span>

    <span class="c1"># Re-shape X, so that we may handle multi-dimensional arrays equivalently</span>
    <span class="c1"># and iterate across 0th axis</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">_verify_alphabet_sufficiently_large</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

    <span class="c1"># Sort columns</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)]</span>

    <span class="c1"># Compute symbol run-lengths</span>
    <span class="c1"># Compute symbol change indicators</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Obtain symbol change positions</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">B</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Compute run lengths</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="p">))</span>

    <span class="n">alphabet_X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">I</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">estimator</span> <span class="o">!=</span> <span class="s2">&quot;ML&quot;</span><span class="p">:</span>
        <span class="n">n_additional_empty_bins</span> <span class="o">=</span> <span class="n">_determine_number_additional_empty_bins</span><span class="p">(</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_additional_empty_bins</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">L</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_remove_counts_at_fill_value</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="c1"># P_0 is the probability mass assigned to each additional empty bin</span>
    <span class="n">P</span><span class="p">,</span> <span class="n">P_0</span> <span class="o">=</span> <span class="n">_estimate_probabilities</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">n_additional_empty_bins</span><span class="p">)</span>
    <span class="n">H_0</span> <span class="o">=</span> <span class="n">n_additional_empty_bins</span> <span class="o">*</span> <span class="n">P_0</span> <span class="o">*</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">P_0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">entropy_pmf</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="n">H_0</span>

    <span class="k">if</span> <span class="n">keep_dims</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="entropy">
<a class="viewcode-back" href="../index.html#discrete_random_variable.entropy">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">entropy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the estimated entropy (see e.g. [CoTh06]) for an array X containing</span>
<span class="sd">    realisations of a discrete random variable.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P(x)` the probability of observing outcome :math:`x`</span>
<span class="sd">    of a discrete random variable :math:`X`, the entropy :math:`H(X)` is</span>
<span class="sd">    defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        H(X) = -\\sum_x {P(x) \\log {P(x)}}.</span>

<span class="sd">    **Estimation**:</span>

<span class="sd">    Entropy is estimated based on frequency tables. See below for a list of</span>
<span class="sd">    available estimators.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        An array containing discrete random variable realisations. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        array; multiple random variables may be specified using preceding axes.</span>
<span class="sd">        When X.ndim==1, returns a scalar. When X.ndim&gt;1, returns an array of</span>
<span class="sd">        estimated entropies with dimensions X.shape[:-1].  X may not contain</span>
<span class="sd">        (floating point) NaN values. Missing data may be specified using numpy</span>
<span class="sd">        masked arrays, as well as using standard numpy array/array-like</span>
<span class="sd">        objects; see below for details.</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    fill_value : object</span>
<span class="sd">        It is possible to specify missing data using numpy masked arrays,</span>
<span class="sd">        pandas Series/DataFrames, as well as using standard numpy</span>
<span class="sd">        array/array-like objects with assigned placeholder values. When using</span>
<span class="sd">        numpy masked arrays, this function invokes np.ma.filled() internally,</span>
<span class="sd">        so that missing data are represented with the array&#39;s object-internal</span>
<span class="sd">        placeholder value fill_value (this function&#39;s fill_value parameter is</span>
<span class="sd">        ignored in such cases). When using pandas Series/DataFrames, an initial</span>
<span class="sd">        conversion to a numpy masked array is performed. When using standard</span>
<span class="sd">        numpy array/array-like objects, this function&#39;s fill_value parameter is</span>
<span class="sd">        used to specify the placeholder value for missing data (defaults to</span>
<span class="sd">        -1).</span>

<span class="sd">        Data equal to the placeholder value are subsequently ignored.</span>
<span class="sd">    estimator : str or float</span>
<span class="sd">        The desired estimator (see above for details on estimators). Possible</span>
<span class="sd">        values are:</span>

<span class="sd">            *&#39;ML&#39; (the default value)* : Maximum likelihood estimator.</span>

<span class="sd">            *any floating point value* : Maximum a posteriori esimator using</span>
<span class="sd">            Dirichlet prior (equivalent to maximum likelihood with pseudo-count</span>
<span class="sd">            for each outcome as specified).</span>

<span class="sd">            *PERKS* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to 1/L, where L is the number of possible outcomes.</span>

<span class="sd">            *MINIMAX* : Maximum a posteriori esimator using Dirichlet prior</span>
<span class="sd">            (equivalent to maximum likelihood with pseudo-count for each</span>
<span class="sd">            outcome set to sqrt(N)/L, where N is the total number of</span>
<span class="sd">            realisations and where L is the number of possible outcomes.</span>

<span class="sd">            *JAMES-STEIN* : James-Stein estimator [HaSt09].</span>

<span class="sd">            *GOOD-TURING* : Good-Turing estimator [GaSa95].</span>

<span class="sd">    Alphabet_X : numpy array (or array-like object such as a list of \</span>
<span class="sd">    immutables, as accepted by np.array())</span>
<span class="sd">        An array specifying the alphabet/alphabets of possible outcomes that</span>
<span class="sd">        random variable realisations in array X may assume. Defaults to None,</span>
<span class="sd">        in which case the alphabet/alphabets of possible outcomes is/are</span>
<span class="sd">        implicitly based the observed outcomes in array X, with no additional,</span>
<span class="sd">        unobserved outcomes. In combination with any estimator other than</span>
<span class="sd">        maximum likelihood, it may be useful to specify alphabets including</span>
<span class="sd">        unobserved outcomes. For such cases, successive possible outcomes of a</span>
<span class="sd">        random variable are indexed by the last axis in Alphabet_X; multiple</span>
<span class="sd">        alphabets may be specified using preceding axes, with the requirement</span>
<span class="sd">        X.shape[:-1]==Alphabet_X.shape[:-1]. Alphabets of different sizes may</span>
<span class="sd">        be specified either using numpy masked arrays, or by padding with the</span>
<span class="sd">        chosen placeholder fill_value.</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True, an additional dimension of length one is appended to</span>
<span class="sd">        the returned array, facilitating any broadcast operations required by</span>
<span class="sd">        the user (defaults to False).</span>

<span class="sd">    **Implementation notes**:</span>

<span class="sd">    Before estimation, outcomes are mapped to the set of non-negative integers</span>
<span class="sd">    internally, with the value -1 representing missing data. To avoid this</span>
<span class="sd">    internal conversion step, supply integer data and use the default fill</span>
<span class="sd">    value -1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NB: We would be able to reduce code duplication by invoking</span>
    <span class="c1"># entropy_cross(X,X). However, performance would likely be lower!</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span>
            <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span>
        <span class="p">)</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span> <span class="o">=</span> <span class="n">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value_X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Alphabet_X contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_isnan</span><span class="p">(</span><span class="n">fill_value_X</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill value for arg X is NaN&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leading dimensions of args X and Alphabet_X do not &quot;</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_map_observations_to_integers</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">),</span> <span class="p">(</span><span class="n">fill_value_X</span><span class="p">,</span> <span class="n">fill_value_Alphabet_X</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">S</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">H</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="c1"># Re-shape H and X, so that we may handle multi-dimensional arrays</span>
    <span class="c1"># equivalently and iterate across 0th axis</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">orig_shape_H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">_verify_alphabet_sufficiently_large</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

    <span class="c1"># NB: This is not joint entropy. Elements in each row are sorted</span>
    <span class="c1"># independently</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Compute symbol run-lengths</span>
    <span class="c1"># Compute symbol change indicators</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Obtain symbol change positions</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Compute run lengths</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="p">))</span>

        <span class="n">alphabet_X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">I</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">estimator</span> <span class="o">!=</span> <span class="s2">&quot;ML&quot;</span><span class="p">:</span>
            <span class="n">n_additional_empty_bins</span> <span class="o">=</span> <span class="n">_determine_number_additional_empty_bins</span><span class="p">(</span>
                <span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fill_value</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_additional_empty_bins</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_remove_counts_at_fill_value</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">alphabet_X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># P_0 is the probability mass assigned to each additional empty bin</span>
        <span class="n">P</span><span class="p">,</span> <span class="n">P_0</span> <span class="o">=</span> <span class="n">_estimate_probabilities</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">n_additional_empty_bins</span><span class="p">)</span>
        <span class="n">H_0</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">n_additional_empty_bins</span>
            <span class="o">*</span> <span class="n">P_0</span>
            <span class="o">*</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">P_0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">entropy_pmf</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="n">H_0</span>

    <span class="c1"># Reverse re-shaping</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">orig_shape_H</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="entropy_pmf">
<a class="viewcode-back" href="../index.html#discrete_random_variable.entropy_pmf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">entropy_pmf</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the entropy (see e.g. [CoTh06]) of an array P representing a</span>
<span class="sd">    discrete probability distribution.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P(x)` the probability mass associated with observing</span>
<span class="sd">    an outcome :math:`x` under distribution :math:`P`, the entropy :math:`H(P)`</span>
<span class="sd">    is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        H(P) = -\\sum_x {P(x) \\log {P(x)}}.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    P : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        An array containing probability mass assignments. Probabilities in a</span>
<span class="sd">        distribution are indexed by the last axis in the array; multiple</span>
<span class="sd">        probability distributions may be specified using preceding axes. When</span>
<span class="sd">        P.ndim==1, returns a scalar. When P.ndim&gt;1, returns an array of</span>
<span class="sd">        entropies with dimensions P.shape[:-1]. P may not contain (floating</span>
<span class="sd">        point) NaN values.</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    require_valid_pmf : boolean</span>
<span class="sd">        When set to True (the default value), verifies that probability mass</span>
<span class="sd">        assignments in each distribution sum to 1. When set to False, no such</span>
<span class="sd">        test is performed, thus allowing incomplete probability distributions</span>
<span class="sd">        to be processed.</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True, an additional dimension of length one is appended to</span>
<span class="sd">        the returned array, facilitating any broadcast operations required by</span>
<span class="sd">        the user (defaults to False).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">P</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">P</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">P</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P contains values outside unit interval&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">require_valid_pmf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P does not sum to unity across last axis&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="n">H</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="entropy_cross_pmf">
<a class="viewcode-back" href="../index.html#discrete_random_variable.entropy_cross_pmf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">entropy_cross_pmf</span><span class="p">(</span>
    <span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the cross entropy (see e.g. [Murp12]) between arrays P and Q, each</span>
<span class="sd">    representing a discrete probability distribution.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P(x)`, :math:`Q(x)` respectively the probability mass</span>
<span class="sd">    associated with observing an outcome :math:`x` under distributions</span>
<span class="sd">    :math:`P`, :math:`Q`, the cross entropy :math:`H^\\times(P,Q)` is defined</span>
<span class="sd">    as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        H^\\times(P,Q) = -\\sum_x {P(x) \\log {Q(x)}}.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    P, Q : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Q is not None*: P and Q are arrays</span>
<span class="sd">        containing probability mass assignments, with P.shape==Q.shape.</span>
<span class="sd">        Probabilities in a distribution are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple probability distributions in P and Q may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (distributions</span>
<span class="sd">        are paired **one-to-one** between P and Q). When P.ndim==Q.ndim==1,</span>
<span class="sd">        returns a scalar. When P.ndim&gt;1 and Q.ndim&gt;1, returns an array of cross</span>
<span class="sd">        entropies with dimensions P.shape[:-1]. Neither P nor Q may contain</span>
<span class="sd">        (floating point) NaN values.</span>

<span class="sd">        *cartesian_product==True and Q is not None*: P and Q are arrays</span>
<span class="sd">        containing probability mass assignments, with P.shape[-1]==Q.shape[-1].</span>
<span class="sd">        Probabilities in a distribution are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple probability distributions in P and Q may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (distributions</span>
<span class="sd">        are paired **many-to-many** between P and Q). When P.ndim==Q.ndim==1,</span>
<span class="sd">        returns a scalar. When P.ndim&gt;1 and Q.ndim&gt;1, returns an array of cross</span>
<span class="sd">        entropies with dimensions np.append(P.shape[:-1],Q.shape[:-1]). Neither</span>
<span class="sd">        P nor Q may contain (floating point) NaN values.</span>

<span class="sd">        *Q is None*: Equivalent to entropy_cross_pmf(P, P, ... ). Thus, a</span>
<span class="sd">        shorthand syntax for computing cross entropies (in bits) between all</span>
<span class="sd">        pairs of probability distributions in P is entropy_cross_pmf(P).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether probability distributions are paired **one-to-one**</span>
<span class="sd">        between P and Q (cartesian_product==False, the default value) or</span>
<span class="sd">        **many-to-many** between P and Q (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    require_valid_pmf : boolean</span>
<span class="sd">        When set to True (the default value), verifies that probability mass</span>
<span class="sd">        assignments in each distribution sum to 1. When set to False, no such</span>
<span class="sd">        test is performed, thus allowing incomplete probability distributions</span>
<span class="sd">        to be processed.</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">P</span>
        <span class="n">cartesian_product</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">P</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Q contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">P</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Q</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Q contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimensions of args P and Q do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trailing dimensions of args P and Q do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">P</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">P</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P contains values outside unit interval&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">Q</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Q</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Q contains values outside unit interval&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">require_valid_pmf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P does not sum to unity across last axis&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">require_valid_pmf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Q does not sum to unity across last axis&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cartesian_product</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">entropy_cross_pmf</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_cartesian_product_apply</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">P</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">H</span><span class="p">[</span><span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">H</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="divergence_kullbackleibler_pmf">
<a class="viewcode-back" href="../index.html#discrete_random_variable.divergence_kullbackleibler_pmf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">divergence_kullbackleibler_pmf</span><span class="p">(</span>
    <span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the Kullback-Leibler divergence (see e.g. [CoTh06]) between arrays</span>
<span class="sd">    P and Q, each representing a discrete probability distribution.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P(x)`, :math:`Q(x)` respectively the probability mass</span>
<span class="sd">    associated with observing an outcome :math:`x` under distributions</span>
<span class="sd">    :math:`P`, :math:`Q`, the Kullback-Leibler divergence</span>
<span class="sd">    :math:`D_{\\mathrm{KL}}(P \\parallel Q)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        D_{\\mathrm{KL}}(P \\parallel Q) =</span>
<span class="sd">        -\\sum_x {P(x) \\log {\\frac{Q(x)}{P(x)}}}.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    P, Q : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Q is not None*: P and Q are arrays</span>
<span class="sd">        containing probability mass assignments, with P.shape==Q.shape.</span>
<span class="sd">        Probabilities in a distribution are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple probability distributions in P and Q may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (distributions</span>
<span class="sd">        are paired **one-to-one** between P and Q). When P.ndim==Q.ndim==1,</span>
<span class="sd">        returns a scalar. When P.ndim&gt;1 and Q.ndim&gt;1, returns an array of</span>
<span class="sd">        divergence values with dimensions P.shape[:-1]. Neither P nor Q may</span>
<span class="sd">        contain (floating point) NaN values.</span>

<span class="sd">        *cartesian_product==True and Q is not None*: P and Q are arrays</span>
<span class="sd">        containing probability mass assignments, with P.shape[-1]==Q.shape[-1].</span>
<span class="sd">        Probabilities in a distribution are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple probability distributions in P and Q may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (distributions</span>
<span class="sd">        are paired **many-to-many** between P and Q). When P.ndim==Q.ndim==1,</span>
<span class="sd">        returns a scalar. When P.ndim&gt;1 and Q.ndim&gt;1, returns an array of</span>
<span class="sd">        divergence values with dimensions np.append(P.shape[:-1],Q.shape[:-1]).</span>
<span class="sd">        Neither P nor Q may contain (floating point) NaN values.</span>

<span class="sd">        *Q is None*: Equivalent to divergence_kullbackleibler_pmf(P, P, ... ).</span>
<span class="sd">        Thus, a shorthand syntax for computing Kullback-Leibler divergence (in</span>
<span class="sd">        bits) between all pairs of probability distributions in P is</span>
<span class="sd">        divergence_kullbackleibler_pmf(P).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether probability distributions are paired **one-to-one**</span>
<span class="sd">        between P and Q (cartesian_product==False, the default value) or</span>
<span class="sd">        **many-to-many** between P and Q (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    require_valid_pmf : boolean</span>
<span class="sd">        When set to True (the default value), verifies that probability mass</span>
<span class="sd">        assignments in each distribution sum to 1. When set to False, no such</span>
<span class="sd">        test is performed, thus allowing incomplete probability distributions</span>
<span class="sd">        to be processed.</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H_cross</span> <span class="o">=</span> <span class="n">entropy_cross_pmf</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">entropy_pmf</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="p">)</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">H_cross</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">H</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">H_cross</span> <span class="o">-</span> <span class="n">H</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="divergence_jensenshannon_pmf">
<a class="viewcode-back" href="../index.html#discrete_random_variable.divergence_jensenshannon_pmf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">divergence_jensenshannon_pmf</span><span class="p">(</span>
    <span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the Jensen-Shannon divergence [Lin91] between arrays P and Q, each</span>
<span class="sd">    representing a discrete probability distribution.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P`, :math:`Q` probability distributions with common</span>
<span class="sd">    domain, the Jensen-Shannon divergence</span>
<span class="sd">    :math:`D_{\\mathrm{JS}}(P \\parallel Q)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        D_{\\mathrm{JS}}(P \\parallel Q) =</span>
<span class="sd">        \\frac{1}{2} D_{\\mathrm{KL}}(P \\parallel M) +</span>
<span class="sd">        \\frac{1}{2} D_{\\mathrm{KL}}(Q \\parallel M)</span>

<span class="sd">    where :math:`M = \\frac{1}{2}(P + Q)` and where</span>
<span class="sd">    :math:`D_{\\mathrm{KL}}(\\cdot \\parallel \\cdot)` denotes the</span>
<span class="sd">    Kullback-Leibler divergence.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    P, Q : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Q is not None*: P and Q are arrays</span>
<span class="sd">        containing probability mass assignments, with P.shape==Q.shape.</span>
<span class="sd">        Probabilities in a distribution are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple probability distributions in P and Q may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (distributions</span>
<span class="sd">        are paired **one-to-one** between P and Q). When P.ndim==Q.ndim==1,</span>
<span class="sd">        returns a scalar. When P.ndim&gt;1 and Q.ndim&gt;1, returns an array of</span>
<span class="sd">        divergence values with dimensions P.shape[:-1]. Neither P nor Q may</span>
<span class="sd">        contain (floating point) NaN values.</span>

<span class="sd">        *cartesian_product==True and Q is not None*: P and Q are arrays</span>
<span class="sd">        containing probability mass assignments, with P.shape[-1]==Q.shape[-1].</span>
<span class="sd">        Probabilities in a distribution are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple probability distributions in P and Q may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (distributions</span>
<span class="sd">        are paired **many-to-many** between P and Q). When P.ndim==Q.ndim==1,</span>
<span class="sd">        returns a scalar. When P.ndim&gt;1 and Q.ndim&gt;1, returns an array of</span>
<span class="sd">        divergence values with dimensions np.append(P.shape[:-1],Q.shape[:-1]).</span>
<span class="sd">        Neither P nor Q may contain (floating point) NaN values.</span>

<span class="sd">        *Q is None*: Equivalent to divergence_jensenshannon_pmf(P, P, ... ).</span>
<span class="sd">        Thus, a shorthand syntax for computing Jensen-Shannon divergence (in</span>
<span class="sd">        bits) between all pairs of probability distributions in P is</span>
<span class="sd">        divergence_jensenshannon_pmf(P).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether probability distributions are paired **one-to-one**</span>
<span class="sd">        between P and Q (cartesian_product==False, the default value) or</span>
<span class="sd">        **many-to-many** between P and Q (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    require_valid_pmf : boolean</span>
<span class="sd">        When set to True (the default value), verifies that probability mass</span>
<span class="sd">        assignments in each distribution sum to 1. When set to False, no such</span>
<span class="sd">        test is performed, thus allowing incomplete probability distributions</span>
<span class="sd">        to be processed.</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">P</span>
        <span class="n">cartesian_product</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">P</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_sanitise_array_input</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Q contains no elements&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">P</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_isnan</span><span class="p">(</span><span class="n">Q</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Q contains NaN values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimensions of args P and Q do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cartesian_product</span> <span class="ow">and</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trailing dimensions of args P and Q do not match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">P</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">P</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P contains values outside unit interval&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">Q</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Q</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Q contains values outside unit interval&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">require_valid_pmf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg P does not sum to unity across last axis&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">require_valid_pmf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg Q does not sum to unity across last axis&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg base not a positive real-valued scalar&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cartesian_product</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">divergence_jensenshannon_pmf</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_cartesian_product_apply</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="n">H1</span> <span class="o">=</span> <span class="n">entropy_pmf</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="n">Q</span><span class="p">),</span> <span class="n">base</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">H1</span>
        <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">entropy_pmf</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="p">)</span>
        <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">entropy_pmf</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<div class="viewcode-block" id="divergence_kullbackleibler_symmetrised_pmf">
<a class="viewcode-back" href="../index.html#discrete_random_variable.divergence_kullbackleibler_symmetrised_pmf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">divergence_kullbackleibler_symmetrised_pmf</span><span class="p">(</span>
    <span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">require_valid_pmf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keep_dims</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the symmetrised Kullback-Leibler divergence [Lin91] between arrays</span>
<span class="sd">    P and Q, each representing a discrete probability distribution.</span>

<span class="sd">    **Mathematical definition**:</span>

<span class="sd">    Denoting with :math:`P`, :math:`Q` probability distributions with common</span>
<span class="sd">    domain, the symmetrised Kullback-Leibler divergence</span>
<span class="sd">    :math:`D_{\\mathrm{SKL}}(P \\parallel Q)` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        D_{\\mathrm{SKL}}(P \\parallel Q) =</span>
<span class="sd">        D_{\\mathrm{KL}}(P \\parallel Q) +</span>
<span class="sd">        D_{\\mathrm{KL}}(Q \\parallel P)</span>

<span class="sd">    where :math:`D_{\\mathrm{KL}}(\\cdot \\parallel \\cdot)` denotes the</span>
<span class="sd">    Kullback-Leibler divergence.</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    P, Q : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False and Q is not None*: P and Q are arrays</span>
<span class="sd">        containing probability mass assignments, with P.shape==Q.shape.</span>
<span class="sd">        Probabilities in a distribution are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple probability distributions in P and Q may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (distributions</span>
<span class="sd">        are paired **one-to-one** between P and Q). When P.ndim==Q.ndim==1,</span>
<span class="sd">        returns a scalar. When P.ndim&gt;1 and Q.ndim&gt;1, returns an array of</span>
<span class="sd">        divergence values with dimensions P.shape[:-1]. Neither P nor Q may</span>
<span class="sd">        contain (floating point) NaN values.</span>

<span class="sd">        *cartesian_product==True and Q is not None*: P and Q are arrays</span>
<span class="sd">        containing probability mass assignments, with P.shape[-1]==Q.shape[-1].</span>
<span class="sd">        Probabilities in a distribution are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple probability distributions in P and Q may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (distributions</span>
<span class="sd">        are paired **many-to-many** between P and Q). When P.ndim==Q.ndim==1,</span>
<span class="sd">        returns a scalar. When P.ndim&gt;1 and Q.ndim&gt;1, returns an array of</span>
<span class="sd">        divergence values with dimensions np.append(P.shape[:-1],Q.shape[:-1]).</span>
<span class="sd">        Neither P nor Q may contain (floating point) NaN values.</span>

<span class="sd">        *Q is None*: Equivalent to</span>
<span class="sd">        divergence_kullbackleibler_symmetrised_pmf(P, P, ... ). Thus, a</span>
<span class="sd">        shorthand syntax for computing symmetrised Kullback-Leibler divergence</span>
<span class="sd">        (in bits) between all pairs of probability distributions in P is</span>
<span class="sd">        divergence_kullbackleibler_symmetrised_pmf(P).</span>
<span class="sd">    cartesian_product : boolean</span>
<span class="sd">        Indicates whether probability distributions are paired **one-to-one**</span>
<span class="sd">        between P and Q (cartesian_product==False, the default value) or</span>
<span class="sd">        **many-to-many** between P and Q (cartesian_product==True).</span>
<span class="sd">    base : float</span>
<span class="sd">        The desired logarithmic base (default 2).</span>
<span class="sd">    require_valid_pmf : boolean</span>
<span class="sd">        When set to True (the default value), verifies that probability mass</span>
<span class="sd">        assignments in each distribution sum to 1. When set to False, no such</span>
<span class="sd">        test is performed, thus allowing incomplete probability distributions</span>
<span class="sd">        to be processed.</span>
<span class="sd">    keep_dims : boolean</span>
<span class="sd">        When set to True and cartesian_product==False an additional dimension</span>
<span class="sd">        of length one is appended to the returned array, facilitating any</span>
<span class="sd">        broadcast operations required by the user (defaults to False). Has no</span>
<span class="sd">        effect when cartesian_product==True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">P</span>
        <span class="n">cartesian_product</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">H1</span> <span class="o">=</span> <span class="n">divergence_kullbackleibler_pmf</span><span class="p">(</span>
        <span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">require_valid_pmf</span>
    <span class="p">)</span>
    <span class="n">H2</span> <span class="o">=</span> <span class="n">divergence_kullbackleibler_pmf</span><span class="p">(</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">cartesian_product</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">require_valid_pmf</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">H2</span><span class="o">.</span><span class="n">T</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">H1</span> <span class="o">+</span> <span class="n">H2</span>

    <span class="k">if</span> <span class="n">keep_dims</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cartesian_product</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_append_empty_bins_using_alphabet</span><span class="p">(</span><span class="n">Counts</span><span class="p">,</span> <span class="n">Alphabet</span><span class="p">,</span> <span class="n">Full_Alphabet</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">Alphabet</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">Full_Alphabet</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
            <span class="n">Full_Alphabet</span><span class="p">[</span><span class="n">Full_Alphabet</span> <span class="o">!=</span> <span class="n">fill_value</span><span class="p">],</span> <span class="n">Alphabet</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">Alphabet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="n">Counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Counts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Alphabet</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">Counts</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">Alphabet</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
        <span class="n">Alphabet</span> <span class="o">=</span> <span class="n">Alphabet</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>
        <span class="n">Counts</span> <span class="o">=</span> <span class="n">Counts</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">Alphabet</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Counts</span><span class="p">,</span> <span class="n">Alphabet</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">Full_Alphabet</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">Alphabet</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">Alph1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Full_Alphabet</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">Full_Alphabet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fill_value</span><span class="p">])</span>
        <span class="n">Alph2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Full_Alphabet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">Full_Alphabet</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fill_value</span><span class="p">])</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">Alph1</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">Alph2</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Full_Alphabet</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Alph2</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Alph1</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">Alph1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">Alph2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">Unseen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Alphabet</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">A</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]):</span>
                <span class="n">Unseen</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">Alphabet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Alphabet</span><span class="p">,</span> <span class="n">A</span><span class="p">[:,</span> <span class="n">Unseen</span><span class="p">]))</span>
        <span class="n">Counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Counts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Alphabet</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">Counts</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="c1"># Sort columns</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Alphabet</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">Alphabet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
            <span class="n">Alphabet</span> <span class="o">=</span> <span class="n">Alphabet</span><span class="p">[:,</span> <span class="n">I</span><span class="p">]</span>
            <span class="n">Counts</span> <span class="o">=</span> <span class="n">Counts</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">Alphabet</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Counts</span><span class="p">,</span> <span class="n">Alphabet</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_autocreate_alphabet</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="n">Lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
    <span class="n">max_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Lengths</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pad_with_fillvalue</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_length</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>

    <span class="n">Alphabet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">pad_with_fillvalue</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">X</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Alphabet</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_cartesian_product_apply</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a function to arrays X and Y, each containing discrete random</span>
<span class="sd">    variable realisations. (Internal function.)</span>

<span class="sd">    **Parameters**:</span>

<span class="sd">    X,Y : numpy array (or array-like object such as a list of immutables, as \</span>
<span class="sd">    accepted by np.array())</span>
<span class="sd">        *cartesian_product==False: X and Y are arrays containing discrete</span>
<span class="sd">        random variable realisations, with X.shape==Y.shape. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple random variables in X and Y may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (random</span>
<span class="sd">        variables are paired **one-to-one** between X and Y). When</span>
<span class="sd">        X.ndim==Y.ndim==1, returns a scalar based on calling function(X,Y).</span>
<span class="sd">        When X.ndim&gt;1 and Y.ndim&gt;1, returns an array with dimensions</span>
<span class="sd">        X.shape[:-1], based on calling function once for each variable pairing</span>
<span class="sd">        in the one-to-one relation.</span>

<span class="sd">        *cartesian_product==True: X and Y are arrays containing discrete random</span>
<span class="sd">        variable realisations, with X.shape[-1]==Y.shape[-1]. Successive</span>
<span class="sd">        realisations of a random variable are indexed by the last axis in the</span>
<span class="sd">        respective arrays; multiple random variables in X and Y may be</span>
<span class="sd">        specified using preceding axes of the respective arrays (random</span>
<span class="sd">        variables are paired **many-to-many** between X and Y). When</span>
<span class="sd">        X.ndim==Y.ndim==1, returns a scalar based on calling function(X,Y).</span>
<span class="sd">        When X.ndim&gt;1 or Y.ndim&gt;1, returns an array with dimensions</span>
<span class="sd">        np.append(X.shape[:-1],Y.shape[:-1]), based on calling function once</span>
<span class="sd">        for each variable pairing in the many-to-many relation.</span>
<span class="sd">    function : function</span>
<span class="sd">        A function with two vector-valued arguments.</span>
<span class="sd">     &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">Y</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">Alphabet_Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">H</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">Alphabet_Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Alphabet_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_X</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">Alphabet_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Alphabet_Y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Alphabet_Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">orig_shape_H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">Alphabet_X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">Alphabet_Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">H</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">Alphabet_X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Alphabet_Y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">H</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Reverse re-shaping</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">orig_shape_H</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">H</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_determine_number_additional_empty_bins</span><span class="p">(</span>
    <span class="n">Counts</span><span class="p">,</span> <span class="n">Alphabet</span><span class="p">,</span> <span class="n">Full_Alphabet</span><span class="p">,</span> <span class="n">fill_value</span>
<span class="p">):</span>
    <span class="n">alphabet_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Full_Alphabet</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">alphabet_sizes</span> <span class="o">!=</span> <span class="n">fill_value</span><span class="p">):</span>
        <span class="n">joint_alphabet_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">alphabet_sizes</span><span class="p">[</span><span class="n">alphabet_sizes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">joint_alphabet_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Numerical overflow detected. Joint alphabet &quot;</span> <span class="s2">&quot;size too large.&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">joint_alphabet_size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">joint_alphabet_size</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_estimate_probabilities</span><span class="p">(</span><span class="n">Counts</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">n_additional_empty_bins</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># TODO Documentation should present the following guidelines:</span>
    <span class="c1"># 1) Good-Turing may be used if slope requirement satisfied and if</span>
    <span class="c1"># unobserved symbols have been defined (TODO Clarify what the requirement</span>
    <span class="c1"># is)</span>
    <span class="c1"># 2) James-Stein approach may be used as an alternative</span>
    <span class="c1"># 3) Dirichlet prior may be used in all other cases</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Counts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">Counts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">Counts</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n_additional_empty_bins</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="n">Counts</span> <span class="o">=</span> <span class="n">Counts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">estimator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">estimator</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">estimator</span><span class="p">)</span> <span class="ow">or</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;ML&quot;</span><span class="p">,</span> <span class="s2">&quot;PERKS&quot;</span><span class="p">,</span> <span class="s2">&quot;MINIMAX&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">estimator</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">estimator</span>
        <span class="k">elif</span> <span class="n">estimator</span> <span class="o">==</span> <span class="s2">&quot;PERKS&quot;</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">Counts</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">n_additional_empty_bins</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">estimator</span> <span class="o">==</span> <span class="s2">&quot;MINIMAX&quot;</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Counts</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">Counts</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">n_additional_empty_bins</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">Counts</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Counts</span><span class="p">)</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">Counts</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">n_additional_empty_bins</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Theta_0 is the probability mass assigned to each additional empty bin</span>
        <span class="k">if</span> <span class="n">n_additional_empty_bins</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Theta_0</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span>
                <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Counts</span><span class="p">)</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">Counts</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">n_additional_empty_bins</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Theta_0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">elif</span> <span class="n">estimator</span> <span class="o">==</span> <span class="s2">&quot;GOOD-TURING&quot;</span><span class="p">:</span>
        <span class="c1"># TODO We could also add a Chen-Chao vocabulary size estimator (See</span>
        <span class="c1"># Bhat Suma&#39;s thesis)</span>

        <span class="c1"># The following notation is based on Gale and Sampson (1995)</span>
        <span class="c1"># Determine histogram of counts N_r (index r denotes count)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">Counts</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Compute symbol change indicators</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">B</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Obtain symbol change positions</span>
        <span class="n">N_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">N_r</span><span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="n">I</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="p">))</span>  <span class="c1"># Compute run lengths</span>
        <span class="n">N_r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Ensures that unobserved symbols do not interfere</span>

        <span class="c1"># Compute Z_r, a locally averaged version of N_r</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">N_r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">R</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Z_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">N_r</span><span class="p">)</span>
        <span class="n">Z_r</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="n">N_r</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">Q</span><span class="p">))</span>

        <span class="c1"># Fit least squares regression line to plot of log(Z_r) versus log(r)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Z_r</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Z_r</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Regression slope &lt; -1 requirement in linear &quot;</span>
                <span class="s2">&quot;Good-Turing estimate not satisfied&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Compute smoothed value of N_r based on interpolation</span>
        <span class="c1"># We need to refer to SmoothedN_{r+1} for all observed values of r</span>
        <span class="n">SmoothedN_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_r</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">SmoothedN_r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">SmoothedN_r</span><span class="o">.</span><span class="n">size</span><span class="p">))</span> <span class="o">*</span> <span class="n">m</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>

        <span class="c1"># Determine threshold value of r at which to use smoothed values of N_r</span>
        <span class="c1"># (SmoothedN_r), as apposed to straightforward N_r.</span>
        <span class="c1"># Variance of Turing estimate</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">VARr_T</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_r</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N_r</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N_r</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N_r</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_r</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_r</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N_r</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_r</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_r</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">SmoothedN_r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="p">(</span><span class="n">SmoothedN_r</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">VARr_T</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">VARr_T</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">turing_is_sig_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">VARr_T</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">turing_is_sig_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># NB: 0th element can be safely ignored, since always 0</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">turing_is_sig_diff</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">False</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">T</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">thresh_r</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Use smoothed estimates from the first non-significant</span>
            <span class="c1"># np.abs(SmoothedN_r-N_r) position onwards</span>
            <span class="n">SmoothedN_r</span><span class="p">[:</span><span class="n">thresh_r</span><span class="p">]</span> <span class="o">=</span> <span class="n">N_r</span><span class="p">[:</span><span class="n">thresh_r</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use only non-smoothed estimates (except for SmoothedN_r[-1])</span>
            <span class="n">SmoothedN_r</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">N_r</span>

        <span class="c1"># Estimate probability of encountering one particular symbol among the</span>
        <span class="c1"># objects observed r times, r&gt;0</span>
        <span class="n">p_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_r</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Counts</span><span class="p">)</span>
        <span class="n">p_r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N_r</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">*</span> <span class="mf">1.0</span>
            <span class="o">*</span> <span class="n">SmoothedN_r</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">SmoothedN_r</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Estimate probability of observing any unseen symbol</span>
        <span class="n">p_r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">N_r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">N</span>

        <span class="c1"># Assign probabilities to observed symbols</span>
        <span class="n">Theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p_r</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Counts</span><span class="p">])</span>
        <span class="n">Theta</span><span class="p">[</span><span class="n">Counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Normalise probabilities for observed symbols, so that they sum to one</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n_additional_empty_bins</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Theta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Theta</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Theta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;No unobserved outcomes specified. Disregarding the &quot;</span>
                <span class="s2">&quot;probability mass allocated to any unobserved &quot;</span>
                <span class="s2">&quot;outcomes.&quot;</span>
            <span class="p">)</span>
            <span class="n">Theta</span> <span class="o">=</span> <span class="n">Theta</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Theta</span><span class="p">)</span>

        <span class="c1"># Divide p_0 among unobserved symbols</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">p_emptybin</span> <span class="o">=</span> <span class="n">p_r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_additional_empty_bins</span><span class="p">)</span>
        <span class="n">Theta</span><span class="p">[</span><span class="n">Counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_emptybin</span>
        <span class="c1"># Theta_0 is the probability mass assigned to each additional empty bin</span>
        <span class="k">if</span> <span class="n">n_additional_empty_bins</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Theta_0</span> <span class="o">=</span> <span class="n">p_emptybin</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Theta_0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">elif</span> <span class="n">estimator</span> <span class="o">==</span> <span class="s2">&quot;JAMES-STEIN&quot;</span><span class="p">:</span>
        <span class="n">Theta</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_estimate_probabilities</span><span class="p">(</span><span class="n">Counts</span><span class="p">,</span> <span class="s2">&quot;ML&quot;</span><span class="p">)</span>
        <span class="n">p_uniform</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">Counts</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">n_additional_empty_bins</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">Lambda</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Theta</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Counts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">*</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">p_uniform</span> <span class="o">-</span> <span class="n">Theta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">n_additional_empty_bins</span> <span class="o">*</span> <span class="n">p_uniform</span><span class="o">**</span><span class="mi">2</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">Lambda</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Lambda</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">Lambda</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Lambda</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Lambda</span><span class="p">):</span>
            <span class="n">Lambda</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">Theta</span> <span class="o">=</span> <span class="n">Lambda</span> <span class="o">*</span> <span class="n">p_uniform</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Lambda</span><span class="p">)</span> <span class="o">*</span> <span class="n">Theta</span>
        <span class="c1"># Theta_0 is the probability mass assigned to each additional empty bin</span>
        <span class="k">if</span> <span class="n">n_additional_empty_bins</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Theta_0</span> <span class="o">=</span> <span class="n">Lambda</span> <span class="o">*</span> <span class="n">p_uniform</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Theta_0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid value specified for estimator&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">Theta_0</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_increment_binary_vector</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="n">carry_1</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">carry_1</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">carry_1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">carry_1</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">carry_1</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">carry_1</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">X</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_isnan</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_isnan_element</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_isnan_element</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_map_observations_to_integers</span><span class="p">(</span><span class="n">Symbol_matrices</span><span class="p">,</span> <span class="n">Fill_values</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">Symbol_matrices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">Fill_values</span><span class="p">)</span>
    <span class="n">FILL_VALUE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">Symbol_matrices</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Fill_values</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FILL_VALUE</span>
    <span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">LabelEncoder</span><span class="p">()</span>
        <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Fill_values</span><span class="p">]</span>
        <span class="n">L</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">A</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">Symbol_matrices</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="p">))</span>
        <span class="c1"># TODO make sure to test with various (unusual) data types</span>
        <span class="n">Symbol_matrices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">L</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">Symbol_matrices</span>
        <span class="p">]</span>
        <span class="n">Fill_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">L</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">Fill_values</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">A</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Symbol_matrices</span><span class="p">,</span> <span class="n">Fill_values</span><span class="p">):</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">FILL_VALUE</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="n">A</span> <span class="o">==</span> <span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">FILL_VALUE</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">Symbol_matrices</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Symbol_matrices</span><span class="p">,</span> <span class="n">FILL_VALUE</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_remove_counts_at_fill_value</span><span class="p">(</span><span class="n">Counts</span><span class="p">,</span> <span class="n">Alphabet</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Alphabet</span><span class="p">)</span> <span class="o">==</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
        <span class="n">Counts</span> <span class="o">=</span> <span class="n">Counts</span><span class="p">[</span><span class="o">~</span><span class="n">I</span><span class="p">]</span>
        <span class="n">Alphabet</span> <span class="o">=</span> <span class="n">Alphabet</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">~</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Counts</span><span class="p">,</span> <span class="n">Alphabet</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_sanitise_array_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Avoid Python 3 issues with numpy arrays containing None elements</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">or</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">X</span> <span class="o">!=</span> <span class="n">NONE_REPLACEMENT</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">NONE_REPLACEMENT</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">NONE_REPLACEMENT</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
        <span class="c1"># Create masked array, honouring Dataframe/Series missing entries</span>
        <span class="c1"># NB: We transpose for convenience, so that quantities are computed for</span>
        <span class="c1"># each column</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">fill_value</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">X</span> <span class="o">==</span> <span class="n">fill_value</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Masked array contains data equal to fill value&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">):</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span>
            <span class="n">current_dtype_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">kind</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">current_dtype_len</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
                <span class="c1"># Fix numpy&#39;s broken array string type behaviour which causes</span>
                <span class="c1"># X.filled() placeholder entries to be no longer than</span>
                <span class="c1"># non-placeholder entries</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Changing numpy array dtype internally to &quot;</span>
                    <span class="s2">&quot;accommodate fill_value string length&quot;</span>
                <span class="p">)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">mask</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">filled</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">kind</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)))</span>
                <span class="n">X</span><span class="p">[</span><span class="n">M</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;biufcmMOSUV&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported array dtype&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">X</span><span class="p">,))</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_verify_alphabet_sufficiently_large</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Alphabet</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">X</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Alphabet</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fill_value</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">Alphabet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fill_value</span>
        <span class="c1"># NB: This causes issues when both arguments contain None. But it is</span>
        <span class="c1"># always called after observations have all been mapped to integers.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">I</span><span class="p">],</span> <span class="n">Alphabet</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">J</span><span class="p">])</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;provided alphabet does not contain all observed &quot;</span> <span class="s2">&quot;outcomes&quot;</span>
            <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_vstack_pad</span><span class="p">(</span><span class="n">Arrays</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="n">max_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">Arrays</span><span class="p">])</span>
    <span class="n">Arrays</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
                <span class="n">fill_value</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">max_length</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">Arrays</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Arrays</span><span class="p">))</span>


<span class="c1"># TODO Avoid hack surrounding fill_type None and numpy arrays with Python 3. Remove support for fill_type None?</span>
<span class="c1"># TODO Tests for keep_dims</span>
<span class="c1"># TODO Should this really be NaN? Is it consistently NaN for all measures?</span>
<span class="c1"># drv.entropy([-1,], estimator=&#39;PERKS&#39;, Alphabet_X = np.arange(100))</span>

<span class="c1"># NB: The following tests should also determine what happens when data contain</span>
<span class="c1"># None, but fill value is not None</span>
<span class="c1"># TODO Test _determine_number_additional_empty_bins using None fill_value etc.</span>
<span class="c1"># / add assertions</span>
<span class="c1"># TODO Test _append_empty_bins_using_alphabet using None fill_value etc. / add</span>
<span class="c1"># assertions</span>
<span class="c1"># TODO Test _autocreate_alphabet using None fill_value / add assertions</span>
<span class="c1"># TODO Test _remove_counts_at_fill_value / add assertions</span>
<span class="c1"># TODO Test _vstack_pad / add assertions</span>
<span class="c1"># TODO Run some integration tests using a mixed-type DataFrame</span>
<span class="c1"># TODO Run tests using unusual pandas arrangements, such as panels /</span>
<span class="c1"># or multi-level Dataframes</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pyitlib 0.3.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">discrete_random_variable</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2016, Peter Foster.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>